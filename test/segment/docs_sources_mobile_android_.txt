Node:
(type) c
(layer)0
	Element:body
			Node:
			(type) h1
			(layer)1
				Element:h1
					Analytics for Android
			Node:
			(type) c
			(layer)1
				Element:p
				Element:a
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Analytics for Android makes it dead simple to send your data to any tool without having to learn, test or implement a new API every time.
			Node:
			(type) c
			(layer)1
				Element:p
					All of our client sources are open-source, so you can
				Element:a
					view Analytics for Android on Github
					, or check out our
				Element:a
					browser and server-side sources
					too.
			Node:
			(type) c
			(layer)1
				Element:p
					Want to stay updated on releases? Subscribe to the
				Element:a
					release feed
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Analytics for Android only supports API 14 (Android 4.0) and higher. You should
				Element:a
					consider
					it too!
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Getting Started
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Step 1: Install the Library
									Node:
									(type) c
									(layer)3
										Element:p
											The recommended way to install the library for Android is with a build system like Gradle. This makes it dead simple to upgrade versions and add integrations. The library is distributed via
										Element:a
											Maven Central
											. Simply add the
										Element:code
											analytics
											module to your
										Element:code
											build.gradle
											:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											dependencies { compile 'com.segment.analytics.android:analytics:4.+' }
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Packaging SDKs for Device-based Connection Modes
									Node:
									(type) c
									(layer)3
										Element:p
											In the interest of keeping our SDK lightweight, the
										Element:code
											analytics
											artifact only installs the Segment integration. This means that all your data will be sent via Segment’s servers to any tools you’ve enabled with server-side-compatible integrations.
									Node:
									(type) c
									(layer)3
										Element:p
										Element:a
											As described here
											, some integrations require or offer
										Element:strong
											Device-based
											connection modes. In those cases, you’ll need to take some additional steps as
										Element:a
											shown in the source documentation here
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Now that the SDK is installed and setup, you’re ready to…
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Step 2. Initialize the Client
									Node:
									(type) c
									(layer)3
										Element:p
											We recommend initializing the client in your
										Element:code
											Application
											subclass.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											// Create an analytics client with the given context and Segment write key. Analytics analytics = new Analytics.Builder(context, YOUR_WRITE_KEY) .trackApplicationLifecycleEvents() // Enable this to record certain application events automatically! .recordScreenViews() // Enable this to record screen views automatically! .build(); // Set the initialized instance as a globally accessible instance. Analytics.setSingletonInstance(analytics);
									Node:
									(type) c
									(layer)3
										Element:p
										Element:strong
											Notes
											:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
											Automatically tracking lifecycle events (
										Element:code
											Application Opened
											,
										Element:code
											Application Installed
											,
										Element:code
											Application Updated
											) and is optional, but highly recommended to hit the ground running with core events!
										Element:li
											This only installs the Segment integration. This means that all your data will be sent server side to tools. If you need to bundle additional integrations client side, you’ll need to take some additional steps as
										Element:a
											shown here
											.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:em
											Optional
											Customizing the Client
									Node:
									(type) c
									(layer)3
										Element:p
											The entry point of the library is through the
										Element:code
											Analytics
											class. As you may have seen in the quickstart, here’s how you initialize the Analytics client with it’s defaults.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											Analytics analytics = new Analytics.Builder(context, writeKey).build();
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											Analytics.Builder
											class lets you customize settings for the Analytics client, including things like the flush interval and packaging Device-based integrations. Please refer to the Javadocs for details on customizable parameters.
									Node:
									(type) c
									(layer)3
										Element:p
											We also maintain a global default instance which is initialized with defaults suitable to most implementations.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											// You can also register your custom instance as a global singleton. Analytics.setSingletonInstance(analytics); Analytics.with(context).track(...);
									Node:
									(type) c
									(layer)3
										Element:p
											In general, we recommend using the Builder method as it provides the greatest flexibility. Keep in mind that you can call
										Element:code
											Analytics.setSingletonInstance
											only
										Element:em
											ONCE
											, so it’s best to stash the initialization code inside your custom Application class.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											public class MyApp extends Application { @Override public void onCreate() { Analytics analytics = new Analytics.Builder(context, writeKey).build(); Analytics.setSingletonInstance(analytics); // Safely call Analytics.with(context) from anywhere within your app! Analytics.with(context).track("Application Started"); } }
									Node:
									(type) c
									(layer)3
										Element:p
											Once you have initialized an Analytics client, you can safely call any of it’s tracking methods from any thread. These events are dispatched asynchronously to our servers and Device-based integrations.
									Node:
									(type) c
									(layer)3
										Element:p
										Element:strong
											Note:
											You should only ever initialize
										Element:em
											ONE
											instance of the Analytics client. These are expensive to create and throw away, and in most cases, you should stick to our singleton implementation to make using the SDK easier.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Step 3. Add Permissions
									Node:
									(type) c
									(layer)3
										Element:p
											Ensure that the necessary permissions are declared in your application’s
										Element:code
											AndroidManifest.xml
											.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											<!-- Required for internet. --> <uses-permission android:name="android.permission.INTERNET"/>
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Identify
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								identify
								lets you tie a user to their actions and record traits about them. It includes a unique User ID and any optional traits you know about them.
						Node:
						(type) c
						(layer)2
							Element:p
								We recommend calling
							Element:code
								identify
								a single time when the user’s account is first created, and only identifying again later when their traits change.
						Node:
						(type) c
						(layer)2
							Element:p
								Example
							Element:code
								identify
								call:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics.with(context).identify("a user's id", new Traits().putName("a user's name"), null);
						Node:
						(type) c
						(layer)2
							Element:p
								We recommend calling
							Element:code
								identify
								a single time when the user’s account is first created, and only identifying again later when their traits change. We’ll remember the previous user id and merge the new traits with the old ones.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								// Initially when you only know the user's name Analytics.with(context).identify(new Traits().putName("Michael Bolton")); // Sometime later in your app when the user gives you their email Analytics.with(context).identify(new Traits().putEmail("mbolton@initech.com"));
						Node:
						(type) c
						(layer)2
							Element:p
								Hold up though! When you actually put that code in your Android app, you’ll need to replace all those hard-coded strings with details about the currently logged-in user.
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								identify
								call has the following fields:
						Node:
						(type) c
						(layer)2
							Element:table
							Element:tr
							Element:td
							Element:code
								userId
							Element:em
								String,optional
							Element:td
								The database ID for this user.
							Element:tr
							Element:td
							Element:code
								traits
							Element:em
								Traits,optional
							Element:td
								A map of traits about the user, such as their name, email, address, etc.
							Element:tr
							Element:td
							Element:code
								options
							Element:em
								Options, optional
							Element:td
								Extra
							Element:a
								options
								for the call.
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								identify
								call has the following fields:
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Track
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								track
								lets you record the actions your users perform. Every action triggers what we call an “event”, which can also have associated properties.
						Node:
						(type) c
						(layer)2
							Element:p
								To get started, our SDK can automatically tracks a few key common events with our
							Element:a
								Native Mobile Spec
								, such as the
							Element:code
								Application Installed
								,
							Element:code
								Application Updated
								and
							Element:code
								Application Opened
								. Simply enable this option during initialization.
						Node:
						(type) c
						(layer)2
							Element:p
								You’ll also want to track events that are indicators of success for your mobile app, like
							Element:strong
								Signed Up
								,
							Element:strong
								Item Purchased
								or
							Element:strong
								Article Bookmarked
								. We recommend tracking just a few important events. You can always add more later!
						Node:
						(type) c
						(layer)2
							Element:p
								Example
							Element:code
								track
								call:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics analytics = new Analytics.Builder(context, writeKey) .trackApplicationLifecycleEvents() .build(); Analytics.with(context).track("Product Viewed", new Properties().putValue("name", "Moto 360"));
						Node:
						(type) c
						(layer)2
							Element:p
								This example
							Element:code
								track
								call tells us that your user just triggered the
							Element:strong
								Product Viewed
								event with a name of “Moto 360.”
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								track
								event properties can be anything you want to record, for example:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics.with(context).track("Purchased Item", new Properties().putValue("sku", "13d31").putRevenue(199.99));
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								track
								call has the following fields:
						Node:
						(type) c
						(layer)2
							Element:table
							Element:tr
							Element:td
							Element:code
								name
							Element:em
								String,required
							Element:td
								A name for the tracked action.
							Element:tr
							Element:td
							Element:code
								properties
							Element:em
								Properties,optional
							Element:td
								A map of properties for this action, e.g. revenue if the action was a purchase.
							Element:tr
							Element:td
							Element:code
								options
							Element:em
								Options,optional
							Element:td
								Extra
							Element:a
								options
								for the call.
						Node:
						(type) c
						(layer)2
							Element:p
								Find details on
							Element:strong
								best practices in event naming
								as well as the
							Element:strong
								in our
							Element:code
								track
								method payload
							Element:a
								Spec
								.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Screen
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:a
								method lets you you record whenever a user sees a screen of your mobile app, along with optional extra information about the page being viewed.
							Element:code
								screen
						Node:
						(type) c
						(layer)2
							Element:p
								You’ll want to record a screen event an event whenever the user opens a screen in your app. This could be a view, fragment, dialog or activity depending on your app.
						Node:
						(type) c
						(layer)2
							Element:p
								Not all services support screen, so when it’s not supported explicitly, the screen method tracks as an event with the same parameters.
						Node:
						(type) c
						(layer)2
							Element:p
								Example
							Element:code
								screen
								call:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								// category "Feed" and a property "Feed Length" Analytics.with(context).screen("Feed", new Properties().putValue("Feed Length", "26")); // no category, name "Photo Feed" and a property "Feed Length" Analytics.with(context).screen(null, "Photo Feed", new Properties().putValue("Feed Length", "26")); // category "Smartwatches", name "Purchase Screen", and a property "sku" Analytics.with(context).screen("Smartwatches", "Purchase Screen", new Properties().putValue("sku", "13d31"));
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								screen
								call has the following fields:
						Node:
						(type) c
						(layer)2
							Element:table
							Element:tr
							Element:td
							Element:code
								category
							Element:em
								String,optional*
							Element:td
								A category for the screen. Optional if name is provided.
							Element:tr
							Element:td
							Element:code
								name
							Element:em
								String,optional*
							Element:td
								A name for the screen. Optional if category is provided.
							Element:tr
							Element:td
							Element:code
								properties
							Element:em
								Properties,optional
							Element:td
								A map of properties for this screen.
							Element:tr
							Element:td
							Element:code
								options
							Element:em
								Options,optional
							Element:td
								Extra
							Element:a
								options
								for the call.
						Node:
						(type) c
						(layer)2
							Element:p
								Find details on the
							Element:strong
								in our
							Element:code
								screen
								payload
							Element:a
								Spec
								.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Group
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								group
								lets you associate an
							Element:a
								identified user
								user with a group. A group could be a company, organization, account, project or team! It also lets you record custom traits about the group, like industry or number of employees.
						Node:
						(type) c
						(layer)2
							Element:p
								This is useful for tools like
							Element:a
								Intercom
								,
							Element:a
								Preact
								and
							Element:a
								Totango
								, as it ties the user to a
							Element:strong
								group
								of other users.
						Node:
						(type) c
						(layer)2
							Element:p
								Example
							Element:code
								group
								call:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics.with(context).group("a user's id", "a group id", new Traits().putEmployees(20));
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								group
								call has the following fields:
						Node:
						(type) c
						(layer)2
							Element:table
							Element:tr
							Element:td
							Element:code
								userId
							Element:em
								String,required
							Element:td
								The database ID for this user.
							Element:tr
							Element:td
							Element:code
								groupdId
							Element:em
								String,required
							Element:td
								The database ID for this group.
							Element:tr
							Element:td
							Element:code
								traits
							Element:em
								Traits,optional
							Element:td
								A map of traits about the group, such as the number of employees, industry, etc.
							Element:tr
							Element:td
							Element:code
								options
							Element:em
								Options,optional
							Element:td
								Extra
							Element:a
								options
								for the call.
						Node:
						(type) c
						(layer)2
							Element:p
								Find more details about
							Element:code
								group
								including the
							Element:strong
								in our
							Element:code
								group
								payload
							Element:a
								Spec
								.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Alias
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								alias
								is how you associate one identity with another. This is an advanced method, but it is required to manage user identities successfully in
							Element:em
								some
								of our integrations.
						Node:
						(type) c
						(layer)2
							Element:p
								In
							Element:a
								Mixpanel
								it’s used to associate an anonymous user with an identified user once they sign up. For
							Element:a
								KISSmetrics
								, if your user switches IDs, you can use ‘alias’ to rename the ‘userId’.
						Node:
						(type) c
						(layer)2
							Element:p
								Example
							Element:code
								alias
								call:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics.with(context).alias(newId) Analytics.with(context).identify(newId);
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								alias
								call has the following fields:
						Node:
						(type) c
						(layer)2
							Element:table
							Element:tr
							Element:td
							Element:code
								newId
							Element:em
								String,required
							Element:td
								The new ID to track this user with.
							Element:tr
							Element:td
							Element:code
								options
							Element:em
								Options,optional
							Element:td
								Extra
							Element:a
								options
								for the call.
						Node:
						(type) c
						(layer)2
							Element:p
								For more details about
							Element:code
								alias
								, including the
							Element:strong
								, check out our
							Element:code
								alias
								call payload
							Element:a
								Spec
								.
						Node:
						(type) c
						(layer)2
							Element:p
								Note that the
							Element:code
								previousId
								will be the value passed in as the
							Element:code
								userId
								, which we cached after you make an
							Element:code
								identify
								call. We will pass that value as the
							Element:code
								previousId
								when you call
							Element:code
								alias
								and pass in a
							Element:code
								newId
								. If you have not called
							Element:code
								identify
								, the
							Element:code
								previousId
								will be the
							Element:code
								anonymousId
								.
						Node:
						(type) c
						(layer)2
							Element:hr
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Selecting Integrations
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								alias
								,
							Element:code
								group
								,
							Element:code
								identify
								,
							Element:code
								page
								and
							Element:code
								track
								calls can all be passed an object of
							Element:code
								options
								that lets you turn certain integrations on or off. By default all integrations are enabled.
						Node:
						(type) c
						(layer)2
							Element:p
								For instance, in the snippet below, the first event is sent to all integrations, but the second one is sent to all except Mixpanel.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								// Sent to all integrations Analytics.with(context).track("Viewed Item", new Properties()); // Sent to all integrations, except Mixpanel Analytics.with(context).track("Purchased Item", new Properties(), new Options().setIntegration(BundledIntegrations.MIXPANEL, false));
						Node:
						(type) c
						(layer)2
							Element:p
								If you have built your own instance of the client, you can also specify a default options object that will be used for each call. In the snippet below,
							Element:em
								NONE
								of the analytics events will be sent to Heap.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								// Disable Heap integration Options defaultOptions = new Options().setIntegration("Heap", false); // Attach the options to our client Analytics analytics = new Analytics.Builder(context, writeKey).defaultOptions(defaultOptions).build(); // Set the client as a global singleton so it can be called from anywhere Analytics.setSingletonInstance(analytics); // Now any calls made with this Analytics client won't be sent to Heap Analytics.with(context).track("Viewed Item", new Properties());
						Node:
						(type) c
						(layer)2
							Element:p
								Notice that in the first snippet, we used an Enum to disable the integration, but in the second snippet, we used a String. In general, we recommend, using the Enum method for Device-based integrations (this way you get type safety, and don’t accidentally disable “GoogleAnalytics” instead of “Google Analytics”), and pass in a String for controlling the behavior of server side integrations.
						Node:
						(type) c
						(layer)2
							Element:p
								Integration flags are
							Element:strong
								case sensitive
								and match
							Element:a
								the integration’s name in the docs
								(i.e. “AdLearn Open Platform”, “awe.sm”, “MailChimp”, etc.).
						Node:
						(type) c
						(layer)2
							Element:p
							Element:strong
								Note:
								Available at the business level, filtering track calls can be done right from the Segment UI on your source schema page. We recommend using the UI if possible since it’s a much simpler way of managing your filters and can be updated with no code changes on your side.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Context
						Node:
						(type) c
						(layer)2
							Element:p
								Context is a dictionary of extra information you can provide about a specific API call. You can add any custom data to the context dictionary that you’d like to have access to in the raw logs. Some keys in the context dictionary have semantic meaning and will be collected for you automatically, e.g. the information about the device the user is on.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								AnalyticsContext analyticsContext = Analytics.with(context).getAnalyticsContext(); context.putValue(...).putReferrer(...).putCampaign(...);
						Node:
						(type) c
						(layer)2
							Element:p
								You can read more about these
							Element:a
								special fields
								.
						Node:
						(type) c
						(layer)2
							Element:p
								If you’d prefer to opt out of automatic data collection, simply clear the context right after initializing the client. It’s important to do this
							Element:em
								BEFORE
								sending any events.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics analytics = new Analytics.Builder(context, writeKey).defaultOptions(defaultOptions).build(); AnalyticsContext context = analytics.getContext(); context.clear();
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								AnonymousId
						Node:
						(type) c
						(layer)2
							Element:p
								You can retrieve the
							Element:code
								anonymousId
								set by the library by using:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics.with(fragment.getActivity()).getAnalyticsContext().traits().anonymousId()
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Debugging
						Node:
						(type) c
						(layer)2
							Element:p
								If you run into any issues while using the Android library, we recommend turning on logging to help us trace the issue. The default singleton instance will have logging turned on if your application is in debug mode. If you’re using a custom instance, simply attach a
							Element:code
								LogLevel
								to the
							Element:code
								Builder
								.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics analytics = new Analytics.Builder(context, writeKey).logLevel(LogLevel.VERBOSE)...build();
						Node:
						(type) c
						(layer)2
							Element:p
								You can choose to disable logging completely (
							Element:code
								LogLevel.NONE
								), turn on basic logging for the SDK (
							Element:code
								LogLevel.BASIC
								), turn on basic logging for Device-based integration (
							Element:code
								LogLevel.INFO
								), or simply log everything (
							Element:code
								LogLevel.VERBOSE
								). We recommend turn logging off in production modes of your app. Logging also helps you see how long integrations take to complete their calls and discover bottlenecks.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Proxy HTTP Calls
						Node:
						(type) c
						(layer)2
							Element:p
								You can point the Android SDK to your own hosted
							Element:a
								proxy
								of the Segment API. This will run the HTTP traffic for the Segment API through the proxy.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics analytics = new Analytics.Builder(this, ANALYTICS_WRITE_KEY) // .connectionFactory(new ConnectionFactory() { @Override protected HttpURLConnection openConnection(String url) throws IOException { String path = Uri.parse(url).getPath(); // Replace YOUR_PROXY_HOST with the address of your proxy, e.g. https://aba64da6.ngrok.io. return super.openConnection("YOUR_PROXY_HOST" + path); } });
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Automatic Screen Tracking
						Node:
						(type) c
						(layer)2
							Element:p
								Our SDK can automatically instrument screen calls. It uses the name of the activity declared in the manifest as the screen name.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics analytics = new Analytics.Builder(context, writeKey) .recordScreenViews() .build();
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Stats
						Node:
						(type) c
						(layer)2
							Element:p
								Local device stats help you quickly see how many events you’ve sent us, the average time taken for bundled integrations to run, etc.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								StatsSnapshot snapshot = Analytics.with(context).getSnapshot(); log(snapshot.integrationOperationAverageDuration); log(snapshot.flushCount);
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Bleeding Edge Releases
						Node:
						(type) c
						(layer)2
							Element:p
								We publish stable releases every second Wednesday, when we tag and release the
							Element:code
								master
								branch.
						Node:
						(type) c
						(layer)2
							Element:p
								After releasing, we also merge the
							Element:code
								dev
								branch merged into
							Element:code
								master
								. In general, code will be available on
							Element:code
								master
								for two weeks before being tagged as a stable release. During this perioud,
							Element:code
								master
								is published as a snapshot — the equivalent of bleeding edge releases. We recommend using the snapshot version to try out upcoming features and fixes that have not been published yet. Simply add the snapshots repo to your repository and Gradle will pull in the latest snapshot build.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								repositories { mavenCentral() maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' } }
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Opt-out
						Node:
						(type) c
						(layer)2
							Element:p
								Depending on the audience for your app (e.g. children) or the countries where you sell your app (e.g. the EU), you may need to offer the ability for users to opt-out of analytics data collection inside your app. You can turn off ALL integrations including Segment itself:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								public void optOut(boolean optOut) { this.optOut.set(optOut); }
						Node:
						(type) c
						(layer)2
							Element:p
								Set the opt-out status for the current device and analytics client combination. This flag is persisted across device reboots, so you can simply call this once during your application (such as in a screen where a user can opt out of analytics tracking).
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Sending Data to Integrations
						Node:
						(type) c
						(layer)2
							Element:p
								There are two ways to send data to your analytics services through this library:
						Node:
						(type) c
						(layer)2
							Element:ol
							Element:li
								Through the Segment servers
							Element:li
								Directly from the device using bundled SDK’s
						Node:
						(type) c
						(layer)2
							Element:p
							Element:strong
								Note:
								Refer to the specific integration’s docs to see if your tool must be bundled in the app or sent server-side.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Cloud-based Connection Modes
									Node:
									(type) c
									(layer)3
										Element:p
											When an integration’s SDK is not packaged, but it is enabled via your dashboard, the request goes through the Segment REST API, and is routed to the service’s server-side API as
										Element:a
											described here
											.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Packaging Device-based Integration SDKs
									Node:
									(type) c
									(layer)3
										Element:p
											By default, our
										Element:code
											analytics
											artifact packages no Device-based integrations.
									Node:
									(type) c
									(layer)3
										Element:p
											We recommend using device-based integrations on a need-to-use basis to reduce the size of your application, and avoid running into the dreaded 65k method limit.
									Node:
									(type) c
									(layer)3
										Element:p
											If you would like to package Device-based integrations, first add the dependencies you need. You can find these in our app when you open the integration for your source.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											compile('com.segment.analytics.android.integrations:google-analytics:+') { transitive = true } compile('io.branch.segment.analytics.android.integrations:library:+') { transitive = true }
									Node:
									(type) c
									(layer)3
										Element:p
											After adding the dependency, you must register the integration with our SDK.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											Analytics analytics = new Analytics.Builder(context, writeKey) .use(GoogleAnalyticsIntegration.FACTORY) .use(BranchIntegration.FACTORY) ... .build();
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Anonymizing IP
						Node:
						(type) c
						(layer)2
							Element:p
								We collect IP address for client-side (iOS, Android, Analytics.js and Xamarin) events automatically.
						Node:
						(type) c
						(layer)2
							Element:p
								If you don’t want us to record your tracked users’ IP in integrations and S3, you can set your event’s
							Element:code
								context.ip
								field to
							Element:code
								0.0.0.0
								. Our server won’t record the IP address of the client for libraries if the
							Element:code
								context.ip
								field is already set.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Migrating to v4
						Node:
						(type) c
						(layer)2
							Element:p
							Element:strong
								Note:
								If you are using version 2 of the Android SDK, you’ll have to make few changes to get up and running with
							Element:a
								version 3
								.
						Node:
						(type) c
						(layer)2
							Element:p
								In version 3, adding a Device-based integration looks like this:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								compile('com.segment.analytics.android:analytics-core:+') { transitive = true } // Add other dependencies as you want here compile('com.segment.analytics.android:analytics-integration-google-analytics:+') { transitive = true } compile('com.segment.analytics.android:analytics-integration-mixpanel:+') { transitive = true } compile('com.segment.analytics.android:analytics-integration-quantcast:+') { transitive = true }
						Node:
						(type) c
						(layer)2
							Element:p
								or, if you wanted to use all Device-based integrations:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								compile('com.segment.analytics.android:analytics:+') { transitive = true }
						Node:
						(type) c
						(layer)2
							Element:p
								In version 4, the
							Element:code
								analytics-core
								artifact is not available any longer. It has been renamed to
							Element:code
								analytics
								(which previously packaged all Device-based integrations). Version 4 of
							Element:code
								analytics
								only includes the Segment integration. Which means, to package a Device-based integration, you must manually add that dependency.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								compile 'com.segment.analytics.android:analytics:+' compile('com.segment.analytics.android.integrations:google-analytics:1.0.0') { transitive = true } compile('io.branch.segment.analytics.android.integrations:library:1.0.0-RELEASE') { transitive = true }
						Node:
						(type) c
						(layer)2
							Element:p
								In addition to adding a dependency, you must point our SDK to the integration.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:code
								Analytics analytics = new Analytics.Builder(context, writeKey) .use(GoogleAnalyticsIntegration.FACTORY) .use(BranchIntegration.FACTORY) ... .build();
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								FAQ
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											What is the latest version of the library?
									Node:
									(type) c
									(layer)3
										Element:p
											The library is published to
										Element:a
											Maven Central
											where you can see all the published releases.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Where is the changelog for the library?
									Node:
									(type) c
									(layer)3
										Element:p
											We publish a changelog in the
										Element:a
											Github repository
											, detailing the changes made in each release.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Can I use the library with Maven?
									Node:
									(type) c
									(layer)3
										Element:p
											Yes! You can use our library with Maven or any custom build system since the
										Element:code
											core
											SDK is simply a JAR.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											<dependency> <groupId>com.segment.analytics.android</groupId> <artifactId>analytics</artifactId> <version>LATEST</version> </dependency>
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How big is the Segment SDK?
									Node:
									(type) c
									(layer)3
										Element:p
											The core Segment SDK is extremely lightweight! It contains just under 1k methods, the JAR weighs in at 123kb and the dex size is 113kb.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How can I easily swap out debugging and production keys?
									Node:
									(type) c
									(layer)3
										Element:p
											This is trivial if you’re using Gradle and build flavors. Simply provide an alternate
										Element:code
											analytics.xml
											for each configuration with different keys in each.
									Node:
									(type) c
									(layer)3
										Element:p
											For other cases, you can also construct custom instances of the client, so you can pass in a different key for it. Set it as the singleton instance, and use the same API everywhere else.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											class MyApp extends Application { @Override public void onCreate() { Analytics analytics; if(BuildConfig.DEBUG) { analytics = new Analytics.Builder(this, debugWriteKey)...build(); } else { analytics = new Analytics.Builder(this, releaseWriteKey)...build(); } Analytics.setSingletonInstance(analytics); // Must be called before any calls to Analytics.with(context) // Now Analytics.with will return the custom instance Analytics.with(this).track("App Launched"); } }
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How does the library queue API calls?
									Node:
									(type) c
									(layer)3
										Element:p
											Our library queues API calls and uploads them in batches so that we don’t drain your user’s battery life by making a network request for each event tracked.
									Node:
									(type) c
									(layer)3
										Element:p
											As soon as you send as an event, we’ll save it to disk, and if queue size reaches your specified maximum queue size (which is 20 by default), we flush the queue and upload all the events in a single batch. Since the data is persisted right away, there is no data loss even if the app is killed, or the operating system crashes.
									Node:
									(type) c
									(layer)3
										Element:p
											The queue behavior may differ for Device-based integrations. For instance, Mixpanel’s SDK queues events and then flushes them when the app goes to the background only.
									Node:
									(type) c
									(layer)3
										Element:p
											This is why even if you see events in the debugger, the Device-based integration may not show them on their dashboards yet, simply because their mobile SDK may still have them queued. The opposite may also happen, that we have some events queued so they haven’t shown up in the debugger, but the Device-based integration has already sent the events to their servers.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Will my events be delivered even if the app is killed?
									Node:
									(type) c
									(layer)3
										Element:p
											We use a persistent disk queue, so even when the app is killed, the events stay on disk. We’ll simply read them from disk and upload the events the next time the app starts. Our queue works on top of
										Element:a
											Tape
											, which is designed to even survive process and system crashes.
									Node:
									(type) c
									(layer)3
										Element:p
											We save up to 1000 calls on disk, and these never expire.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											I need to use the SDK on an older version of Android not supported by your library!
									Node:
									(type) c
									(layer)3
										Element:p
											Our Android library has support for back to API level 14 (Android 4.0). You should
										Element:a
											consider
											it too! If you can’t do this for your own application, there are three options we’ve recommended to users:
									Node:
									(type) c
									(layer)3
										Element:ol
										Element:li
											Use an older version of the library that does support your minimum requirements. Keep in mind that there won’t be any updates or bug fixes to those versions, but we do still have clients still using old versions of the library in production.
										Element:li
											Skip analytics for users on older devices - you can wrap calls to our SDK in a Build.VERSION check.
										Element:li
											Write your own SDK. You can still use most of the tools on Segment via our
										Element:a
											HTTP API
											. You can use either our Android or
										Element:a
											Java source
											to get a quick headstart.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How can I use an integration specific feature, e.g. Mixpanel’s push notifications?
									Node:
									(type) c
									(layer)3
										Element:p
											If you’re using a Device-based Connection Mode for a mobile integration, you can always access features from that tool’s native SDK.
									Node:
									(type) c
									(layer)3
										Element:p
											To make sure you use the same instance of these integrations as we do, you can register a listener that notifies you when the integrations are ready. This will be called synchronously if the integrations are notified, and asynchronously if the integrations aren’t yet ready.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											analytics.onIntegrationReady("Crittercism", new Callback() { @Override public void onIntegrationReady(Object instance) { // Crittercism uses static methods only, so the instance returned is null. Crittercism.leaveBreadcrumb(); } }); analytics.onIntegrationReady("Mixpanel", new Callback() { @Override public void onIntegrationReady(Object instance) { MixpanelAPI mixpanelAPI = (MixpanelAPI) instance; mixpanelAPI.clearSuperProperties(); } });
									Node:
									(type) c
									(layer)3
										Element:p
											For the integrations that return
										Element:code
											Void
											, they simply use a shared instance. You can call into the SDK directly. With this API, you’re guaranteed that they’ve been initialized first, and if you ever decide to change the settings for the integration on our dashboard, they’ll be reflected here.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											analytics.onIntegrationReady(BundledIntegration.FLURRY, new Callback() { @Override public void onIntegrationReady(Object instance) { // Flurry uses static methods only, so the instance returned is null. Flurry.setLogEnabled(true); } });
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Why is my callback not being invoked?
									Node:
									(type) c
									(layer)3
										Element:p
											If you’re using the integration callbacks described above, and don’t receive a callback, check your proguard configuration. Any easy way to verify that Proguard is the issue is to disable it completely for a run and see if the callbacks is invoked.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Why is Google Analytics not receiving crash reports?
									Node:
									(type) c
									(layer)3
										Element:p
											This is a known bug
										Element:a
											https://code.google.com/p/analytics-issues/issues/detail?id=443
											and is being worked on by Google. We recommend using alternatives like Bugsnag or Crittercism in the meantime.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How should I configure Proguard?
									Node:
									(type) c
									(layer)3
										Element:p
											For our SDK, you should add
										Element:code
											-keep class com.segment.analytics.** { *; }
											to your proguard configuration. You should also look up any proguard configurations recommended by each of the Device-based integrations on their respective docs and websites.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How should I use Outbound’s push notifications?
									Node:
									(type) c
									(layer)3
										Element:p
											Since Outbound isn’t a Device-based integration, you’ll have to set it up manually.
									Node:
									(type) c
									(layer)3
										Element:p
											First, you’ll need to set up the
										Element:a
											GCM client as described in the instructions
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Our server’s will look for
										Element:code
											context.device.token
											key to send to Outbound. Once you have the registration ID from the step above, simply set it on the context. (This convenience method was added in versino 2.1.6).
										Element:code
											analytics.getContext().putDeviceToken(registrationId);
									Node:
									(type) c
									(layer)3
										Element:p
											The entire code flow looks a bit like this:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											String registrationId = loadRegistrationId(); // look up a cached value if(registrationId == null) { registrationId = register(SENDER_ID); // using GoogleCloudMessaging save(registrationId); // save the registration ID } analytics.getContext().putDeviceToken(registrationId);
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Migrate from v2 to v3
									Node:
									(type) c
									(layer)3
										Element:p
										Element:strong
											NOTE
											: Version 3 of the SDK is now replaced by version 4. See the section below on upgrading. If you are already using version 2 of the Android SDK, you’ll have to make few changes to get up and running with version 3.
									Node:
									(type) c
									(layer)3
										Element:p
											In version 3, we’ve organized the integrations to be make the core SDK even leaner and smaller. This is what the old setup looked like:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											compile('com.segment.analytics.android:analytics-core:+') { transitive = true } // Add other dependencies as you want here compile 'com.google.android.gms:play-services:+' compile 'com.mixpanel.android:mixpanel-android:+@aar' compile files('libs/QuantcastAndroidSdk.jar')
									Node:
									(type) c
									(layer)3
										Element:p
											In the new version, instead of adding the integrations directly, simply add our integration modules as a dependency instead. This also ensures that the version of the Device-based integration you’re using, matches the one we depend on.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											compile('com.segment.analytics.android:analytics-core:+') { transitive = true } // Add other dependencies as you want here compile('com.segment.analytics.android:analytics-integration-google-analytics:+') { transitive = true } compile('com.segment.analytics.android:analytics-integration-mixpanel:+') { transitive = true } compile('com.segment.analytics.android:analytics-integration-quantcast:+') { transitive = true }
									Node:
									(type) c
									(layer)3
										Element:p
											Earlier, you could control the debugging behaviour with a boolean flag. In version 3, this is replaced by the more powerful
										Element:a
											Enum, that lets you not only control the logging behaviour of our SDK, but also for Device-based integrations.
										Element:code
											LogLevel
									Node:
									(type) c
									(layer)3
										Element:p
											Version 2 of the SDK also let you customize the behaviour of the SDK by providing resource values in XML. Version 3 ignores these custom options from XML to simplify behaviour and improve performance. The recommended way to customize the Analytics client is to use the
										Element:a
											Builder
											methods instead.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Do you support Phonegap/Cordova?
									Node:
									(type) c
									(layer)3
										Element:p
											Yep! You can use our browserify’d
										Element:a
											analytics-node
											package just like any other client-side JavaScript library.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do you handle Unique Identifiers?
									Node:
									(type) c
									(layer)3
										Element:p
											A key component of any analytics platform is consistently and accurately identifying users. Some kind of ID must be assigned and persisted on the device so that user actions can be effectively studied. This is especially important for funnel conversion analysis and retention analysis.
									Node:
									(type) c
									(layer)3
										Element:p
											Naturally the Analytics SDK needs a unique ID for each user. The very first time an app is launched, our SDK will generated a UUID and save it on disk. This is used as the
										Element:code
											anonymousId
											and stays constant for the user on the device. If you want to create a new user on the same device, call
										Element:code
											reset
											on the Analytics client.
									Node:
									(type) c
									(layer)3
										Element:p
											Our SDK also collects the
										Element:a
											Advertising ID
											provided by Play Services. Make sure the Play Services Ads library is included as a dependency for your application. This is the ID that should be used for advertising purposes. This value will be set to
										Element:code
											context.device.advertisingId
											.
									Node:
									(type) c
									(layer)3
										Element:p
											We also collect the
										Element:a
											Android ID
											as
										Element:code
											context.device.id
											. Some integrations rely on this field being the Android ID, so take care if you choose to override the default value.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Troubleshooting
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											No events in third-party integration
									Node:
									(type) c
									(layer)3
										Element:p
											If you aren’t seeing data in the third-party integration, there are a few possibilities that may be the causing this.
									Node:
									(type) c
									(layer)3
										Element:p
											First, verify that your integration is enabled! You might have used the wrong Segment source (often when switching between development and production), or somebody on your team might have turned it off.
									Node:
									(type) c
									(layer)3
										Element:p
											If the events show up in the segment debugger, look at the raw json and find the
										Element:code
											integrations
											property. If the value is set to
										Element:a
											, that means that the data is being sent from the device to the integration SDK, and not through Segment’s servers. This is expected if you elected to use a Device-based integration’s SDK with Segment’s during installation. If the integration is Cloud-based, you should be able to
										Element:code
											false
										Element:a
											see any errors
											in our debugger itself.
									Node:
									(type) c
									(layer)3
										Element:p
											If the integration is Device-based, enabled
										Element:a
											verbose logging
											, and this will show whether our SDK is calling the partner SDK methods as expected.
									Node:
									(type) c
									(layer)3
										Element:p
											With Mixpanel as an example, you might see something like this in your logcat:
										Element:code
											10-16 20:26:38.607 2046-2067/com.segment.analytics.sample V/Analytics-Mixpanel: MixpanelAPI.getInstance(context, 540f9234e0dfa14f843e59f1acdbafd8);
											.
									Node:
									(type) c
									(layer)3
										Element:p
											This shows you exactly what method was invoked and the arguments it was invoked with!
									Node:
									(type) c
									(layer)3
										Element:p
											If everything looks as expected, please contact the support team for the respective integration partner to ask them why calling the right methods on their SDK would be causing an issue.
									Node:
									(type) c
									(layer)3
										Element:p
											If not, kindly
										Element:a
											enable debugging
											, play around with the app, save the logcat to a file with
										Element:code
											adb logcat >> log.txt
											and then
										Element:a
											contact us
											for help.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Still having issues?
									Node:
									(type) c
									(layer)3
										Element:p
											Feel free to
										Element:a
											reach out to us
											at with the following information:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
											The version of our Android SDK you are using.
										Element:li
											How you installed our SDK.
										Element:li
											Is this a Device-based integration?
										Element:li
											Your logs by enabling
										Element:a
											verbose logging
											sending the output of
										Element:code
											adb logcat
											).
										Element:li
											Screenshots of the event in the Segment debugger.
									Node:
									(type) c
									(layer)3
										Element:p
											We are happy to help!
									Node:
									(type) c
									(layer)3
										Element:hr
									Node:
									(type) c
									(layer)3
										Element:p
											If you have any questions or see anywhere we can improve our documentation, please
										Element:a
											let us know
											or kick off a conversation in the
										Element:a
											Segment Community
											!
									Node:
									(type) c
									(layer)3
										Element:footer
										Element:span
										Element:span
											Was this document helpful?
										Element:span
										Element:label
										Element:span
											Yes
										Element:label
										Element:span
											No
									Node:
									(type) c
									(layer)3
										Element:i
			Node:
			(type) h1
			(layer)1
				Element:h1
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
				Element:a
					Overview
				Element:li
				Element:a
					ActiveCampaign
				Element:li
				Element:a
					AMP
				Element:li
				Element:a
					analytics.js
				Element:li
				Element:a
					Android
				Element:li
				Element:a
					Android Wear
				Element:li
				Element:a
					Clojure
				Element:li
				Element:a
					Customer.io
				Element:li
				Element:a
					Drip
				Element:li
				Element:a
					Facebook Ads
				Element:li
				Element:a
					Facebook Lead Ads
				Element:li
				Element:a
					Go
				Element:li
				Element:a
					Google AdWords
				Element:li
				Element:a
					HTTP
				Element:li
				Element:a
					HubSpot
				Element:li
				Element:a
					Intercom
				Element:li
				Element:a
					iOS
				Element:li
				Element:a
					Iterable
				Element:li
				Element:a
					Java
				Element:li
				Element:a
					Klaviyo
				Element:li
				Element:a
					Mailchimp
				Element:li
				Element:a
					Mailjet
				Element:li
				Element:a
					Marketo
				Element:li
				Element:a
					Node
				Element:li
				Element:a
					Nudgespot
				Element:li
				Element:a
					PHP
				Element:li
				Element:a
					Python
				Element:li
				Element:a
					Ruby
				Element:li
				Element:a
					Salesforce
				Element:li
				Element:a
					Selligent
				Element:li
				Element:a
					SendGrid
				Element:li
				Element:a
					Stripe
				Element:li
				Element:a
					Twilio
				Element:li
				Element:a
					Vero
				Element:li
				Element:a
					Xamarin
				Element:li
				Element:a
					Zendesk
				Element:li
				Element:a
					.NET
