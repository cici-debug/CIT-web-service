Node:
(type) c
(layer)0
	Element:body
			Node:
			(type) h1
			(layer)1
				Element:h1
					Complete Reference
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Below you'll find in-depth textual descriptions of terminology around our Developer Platform. You probably
					↑ Was this documentation useful?
				Element:strong
					do not
					want to start by reading this all the way through. Rather, use it as a reference when you run into trouble when creating your App.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Apps
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A Developer App (App for short) is an implementation of your app's API. It's the thing you build to make Zapier support your app.
			Node:
			(type) c
			(layer)1
				Element:p
					An App is composed of four main parts:
			Node:
			(type) c
			(layer)1
				Element:ul
					↑ Was this documentation useful?
				Element:li
				Element:a
					Authentication
					(usually) which lets us know what credentials we need to ask users for and where to include them in the requests we make to your API.
				Element:li
				Element:a
					Triggers
					, which read data
				Element:strong
					from
					your API.
				Element:li
				Element:a
					Actions
					, which send data
				Element:strong
					to
					your API.
				Element:li
				Element:a
					Searches
					, which find specific records
				Element:strong
					in
					your API.
				Element:li
					Code written in
				Element:a
					scripting
					that lets you handle any mismatches between what Zapier needs and what your API generates.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Actions
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Overview
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:p
								Actions answer the question:
							Element:em
								What should my users be able to create via Zapier?
								They are things like:
						Node:
						(type) c
						(layer)2
							Element:ul
							Element:li
								Create ToDo Task
							Element:em
								(EG: Basecamp)
							Element:li
								Create Chat Message
							Element:em
								(EG: Campfire or Hipchat)
							Element:li
								Create Issue
							Element:em
								(EG: GitHub or Pivotal Tracker)
						Node:
						(type) c
						(layer)2
							Element:p
								You can think of Actions as POSTs, writes, or the creation of a resource. It involves Zapier sending data to your app.
						Node:
						(type) c
						(layer)2
							Element:p
								What a user sees:
						Node:
						(type) c
						(layer)2
							Element:p
							Element:img
						Node:
						(type) c
						(layer)2
							Element:p
								What a developer sees:
						Node:
						(type) c
						(layer)2
							Element:p
							Element:img
						Node:
						(type) c
						(layer)2
							Element:p
								See also:
							Element:a
								Actions in the CLI
						Node:
						(type) c
						(layer)2
							Element:p
								You can define your actions via your app's dashboard. When you create a new action, you'll be prompted with several options. Below are complete definitions of what each option is for.
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Action Options
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Name
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											This is a human readable label a user would see when browsing the directory and adding your app. Make it short but descriptive.
									Node:
									(type) c
									(layer)3
										Element:p
											Example:
										Element:br
										Element:code
											Create Issue
											,
										Element:code
											Send Alert
											or
										Element:code
											Unsubscribe User
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Noun
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											This is the object that the action is most closely associated with. It will be a noun you used in the Name field. We rely on an accurate noun to generate human-friendly sentences for users.
									Node:
									(type) c
									(layer)3
										Element:p
											Example:
										Element:br
											"Create Issue" would have "Issue" as the noun. "Unsubscribe User" would use "User".
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Key
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											This is a field only really used internally for both
										Element:a
											dynamic dropdowns
											and
										Element:a
											scripting
											references. Needs to be at least two characters long, start with an alpha, and only contain
										Element:code
											a-z
											,
										Element:code
											A-Z
											,
										Element:code
											0-9
											or
										Element:code
											_
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Example:
										Element:br
										Element:code
											create_issue
											,
										Element:code
											ticket
											or
										Element:code
											newNote
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Help Text
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											This some human readable explanatory text, usually something that clarifies what the action does.
									Node:
									(type) c
									(layer)3
										Element:p
											Example:
										Element:br
										Element:code
											Creates a new issue in a selected repository.
									Node:
									(type) c
									(layer)3
										Element:p
										Element:em
											The user will see
										Element:strong
											Name
											and
										Element:strong
											Help Text
											like below:
									Node:
									(type) c
									(layer)3
										Element:p
										Element:img
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Action Endpoint URL
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											Define the URL where we will, by default,
										Element:code
											POST
											the payload to. You can also make use of
										Element:a
											variable syntax
											where
										Element:a
											auth fields
											and
										Element:a
											action fields
											will be injected.
									Node:
									(type) c
									(layer)3
										Element:p
											Example:
										Element:br
										Element:code
											http://api.example.com/v2/clients.json
											or
										Element:code
											http://{{account}}.example.com/api/v1/projects.json
									Node:
									(type) c
									(layer)3
										Element:a
									Node:
									(type) c
									(layer)3
												Node:
												(type) c
												(layer)4
													Element:h4
														A Warning about encoding URL params
													Element:a
														#
												Node:
												(type) c
												(layer)4
													Element:p
														We will not automatically encode any URL variables, so you're responsible for encoding any if they require that. For example, emails
													Element:em
														might
														include a
													Element:code
														+
														sign, so if you have
													Element:code
														https://example.com/api/v2/clients.json?email={{email}}
														you'll want to encode that in your
													Element:a
														(or remove it from there and add it to the
													Element:code
														ACTION_KEY_pre_write
													Element:code
														bundle.request.params
														), otherwise you'll get a "space" where the
													Element:code
														+
														sign is.
												Node:
												(type) c
												(layer)4
													Element:p
														A better approach is to not even include it in the URL (it'll be added and encoded automatically in that case)
												Node:
												(type) c
												(layer)4
													Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Custom Action Fields URL
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											This allows you to dynamically define action fields that are user set (IE: custom fields). They get passed into the POST'ed JSON just like normal action fields (or into
										Element:a
											scripting
											).
									Node:
									(type) c
									(layer)3
										Element:p
											Example:
										Element:br
										Element:code
											http://api.example.com/v2/fields.json
											or
										Element:code
											http://{{account}}.example.com/api/v1/fields.json
									Node:
									(type) c
									(layer)3
										Element:blockquote
										Element:p
											Read more about
										Element:a
											custom field formatting here
											.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Important
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											Usually you'll want to leave this checked, but if you don't we'll hide that action behind an "uncommon" link when a user selects their action. Mainly this is helpful for removing actions that are there for breadth but are rarely used.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Hide
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											Usually you'll want to leave this unchecked. If you check it, we'll completely hide the action from the enduser. This can be useful if an action is incomplete, but you need to deploy your app in it's current state. This option is also a way to hide actions that become deprecated in your API.
											↑ Was this documentation useful?
									Node:
									(type) c
									(layer)3
										Element:span
										Element:a
											Yes
										Element:a
											No
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Action Fields
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Overview
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Action Fields answer the question: what details can a user provide when setting up an Action?
			Node:
			(type) c
			(layer)1
				Element:p
					These details might include:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Title
				Element:em
					(EG: Note Title in Evernote)
				Element:li
					Description
				Element:em
					(EG: Issue Description in Github)
				Element:li
					Parent Object
				Element:em
					(span relationships via
				Element:a
					dynamic dropdowns
					)
				Element:li
					Repo for an Issue
				Element:em
					(EG: Github)
				Element:li
					Notebook for a Note
				Element:em
					(EG: Evernote)
				Element:li
					Message Body
				Element:em
					(EG: Chat Body in Campfire or Hipchat)
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Each action should have at least one action field, because, hey, it really makes no sense to POST nothing to an endpoint!
			Node:
			(type) c
			(layer)1
				Element:p
					You can also dynamically load custom action fields by inspecting a custom field endpoint of your own.
				Element:a
					Learn more.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Action Field Options
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A key for you and your API's consumption. This is available for
				Element:a
					variable syntax
					in the Action URL field as well as being added to the POSTed JSON (optional). Needs to be at least two characters long, start with an alpha, and only contain
				Element:code
					a-z
					,
				Element:code
					A-Z
					,
				Element:code
					0-9
					or
				Element:code
					_
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					room
			Node:
			(type) c
			(layer)1
				Element:p
					We'll take double underscores and convert them to nested dictionaries before we POST JSON.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					project__title
					converts to
				Element:code
					{"project": {"title": "some value"} }
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Label
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A human readable Label shown in the UI as a user works to complete an Action.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Room
					or
				Element:code
					Title
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Help Text
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Human readable description of an action field, useful for describing some detail you couldn't list in the Label.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Choose which room to send the message to.
					or
				Element:code
					Add a title to the note.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Default
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A default value for a field. The behavior varies between required and optional fields. For required fields, the default will be set once when the user first creates the Action, but it is not guaranteed after that (we raise an error on missing/null values instead). For optional fields, it is set on initial creation and used in place of missing or null values every time the Zap runs.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Type
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The type we will try to coerce to on the backend. Fails silently to ensure that tasks aren't dropped on coercion errors.
			Node:
			(type) c
			(layer)1
				Element:p
					You can get a full list of supported types and the coercion implied here:
				Element:a
					Field Types
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Required
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If checked a user will not be able to continue without entering some value.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Dynamic Dropdown
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Use an existing
				Element:a
					Trigger
					to load in values for selection, using the machine readable value your API consumes (like
				Element:code
					id
					or
				Element:code
					hash
					) while showing a human readable version to the user (like
				Element:code
					name
					or
				Element:code
					itemName
					).
			Node:
			(type) c
			(layer)1
				Element:p
					Refer to our
				Element:a
					dynamic dropdown docs
					for a more in depth explanation.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					TRIGGERKEY.id.name
					or
				Element:code
					TRIGGERKEY.hash.itemName
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Static Dropdowns
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A comma separated string that will be turned into a select field for limiting the choices a user can provide to an action field.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					choice_a,choice_b,choice_c
					or
				Element:code
					Yesterday, Today, Tomorrow
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					If you would like to provide a label for the raw value of each choice, you can also use the raw|label,raw|label syntax instead.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					1|Option 1,2|Option 2
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Search Connector
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Use an existing
				Element:a
					Search
					to find a value based on user input. Set the key of this field to the
				Element:strong
					same
					key as the field in the search you want to use in executing the search. The second part of the definition is the attribute of the returned object that is sent to your service
				Element:em
					in place of
					this field.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					SEARCHKEY.id
			Node:
			(type) c
			(layer)1
				Element:p
					The above definition sets the field as an input to SEARCHKEY (as long as the field key matches a field key within SEARCHKEY), and the
				Element:code
					id
					field from the first result returned from SEARCHKEY is used as the value for this field.
			Node:
			(type) c
			(layer)1
				Element:p
					The user does not see anything different for this type of field, so make sure to explain in the help text what kind of input you expect here.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					Note
					: Any field with a search connector specified must also have a dynamic dropdown specified. This is because search connectors are meant to save the user from having to find and copy an ID value into a field - which the dynamic dropdown will handle for when the user wants to use the same ID every time.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Parent Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Ok, parent key is a little tricky, but it can be really helpful if you want to support line items (an array of sub-objects). When an action has one or more fields that have a parent key, we treat all those fields as the schema for building sub-objects, which we combine into a list and nest under the parent key.
			Node:
			(type) c
			(layer)1
				Element:p
					For example, say you define two fields
				Element:code
					amount
					and
				Element:code
					quantity
					and give them both the parent key
				Element:code
					line_items
					. Now imagine a user has a trigger that provides this data:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"sale"
				Element:span
					:
				Element:span
					{
				Element:span
					"items_sold"
				Element:span
					:
				Element:span
					[
				Element:span
					{
				Element:span
					"cost"
				Element:span
					:
				Element:span
					"$3.00"
				Element:span
					,
				Element:span
					"# sold"
				Element:span
					:
				Element:span
					12
				Element:span
					},
				Element:span
					{
				Element:span
					"cost"
				Element:span
					:
				Element:span
					"$2.55"
				Element:span
					,
				Element:span
					"# sold"
				Element:span
					:
				Element:span
					1
				Element:span
					}
				Element:span
					]
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					NOTE:
					The kind of data you receive ultimately depends on what the app's trigger providing the data returns. This means that if the app's trigger a customer's using doesn't provide line items, we'll transform arrays into CSV strings. There's really nothing you can do about this, but when testing,
				Element:a
					make sure the app you're using to test triggers supports line items
					.
			Node:
			(type) c
			(layer)1
				Element:p
					The user could map
				Element:code
					cost
					into your amount field and
				Element:code
					# sold
					into the action's quantity field, like this:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Zapier would produce this JSON for POSTing:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"line_items"
				Element:span
					:
				Element:span
					[
				Element:span
					{
				Element:span
					"amount"
				Element:span
					:
				Element:span
					"$3.00"
				Element:span
					,
				Element:span
					"quantity"
				Element:span
					:
				Element:span
					12
				Element:span
					},
				Element:span
					{
				Element:span
					"amount"
				Element:span
					:
				Element:span
					"$2.55"
				Element:span
					,
				Element:span
					"quantity"
				Element:span
					:
				Element:span
					1
				Element:span
					}
				Element:span
					]
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					Zapier will
				Element:em
					automatically
					expand fields with the same
				Element:code
					parent_key
					into a nested list of objects according to how the source data comes in (we'll make as many objects inside the list as the original source). All you need to do is provide the same
				Element:code
					parent_key
					and expect an array of objects under that
				Element:code
					parent_key
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Send in POST by default
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If checked, we'll include the user-provided value in the POSTed JSON on the provided key (or nested key if double underscores
				Element:code
					__
					are present).
			Node:
			(type) c
			(layer)1
				Element:p
					If you utilize the
				Element:code
					pre_poll
					or
				Element:code
					ACTIONKEY_pre_poll
					methods via
				Element:a
					scripting
					you can get complete control over the JSON output beyond simple exclusion/inclusion.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					List
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Indicates if this field can hold multiple values. For example, this could be useful if you want to allow users to add tags to a new contact, and you want them to be able to add more than one. List fields gain the +/- icons to the side.
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:img
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Action Fields (Custom)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A natural extension of normal hard coded
				Element:a
					action fields
					are dynamic action fields, or custom fields. These are extremely common for contacts in CRMs or ticket fields in helpdesk software. All you need to do to enable custom fields is:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Provide a
				Element:code
					Custom Action Fields URL Route
					for the actions in question.
				Element:li
					Ensure the URL route returns data in the below format, or manipulate to fit with
				Element:a
					scripting
					.
				Element:li
					You can choose from several internal types, documented here:
				Element:a
					Field Types
					.
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"type"
				Element:span
					:
				Element:span
					"unicode"
				Element:span
					,
				Element:span
					"key"
				Element:span
					:
				Element:span
					"json_key"
				Element:span
					,
				Element:span
					// the field "name", will be used to construct a label if none is provided
				Element:span
					"required"
				Element:span
					:
				Element:span
					false
				Element:span
					,
				Element:span
					// whether this field must be filled out. defaults to true
				Element:span
					"label"
				Element:span
					:
				Element:span
					"Pretty Label"
				Element:span
					,
				Element:span
					// optional
				Element:span
					"help_text"
				Element:span
					:
				Element:span
					"Helps to explain things to users."
				Element:span
					,
				Element:span
					// optional
				Element:span
					"choices"
				Element:span
					:
				Element:span
					{
				Element:span
					// optional
				Element:span
					"raw"
				Element:span
					:
				Element:span
					"label"
				Element:span
					}
				Element:span
					// can also be a flat array if raw is the label
				Element:span
					},
				Element:span
					...
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					Right now
				Element:code
					parent_key
					and
				Element:code
					type=dict
					is not supported in custom fields.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Action Sample Results
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					(This works similar to
				Element:a
					trigger sample results
					)
			Node:
			(type) c
			(layer)1
				Element:p
					To help give users a smooth experience when creating multi-step Zaps, we ask that you paste a JSON object that contains the fields (along with sample values), so that your user can map those fields into the next step.
			Node:
			(type) c
			(layer)1
				Element:p
					We will use this sample JSON for two things:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					To detect a list of hard-coded key names which the user can pick from during Zap setup
				Element:li
					To use as a hard-coded fallback for sample data so that we can provide fields to insert during Zap setup (if your API returns 0 results)
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					These results will NOT be used for a user's Zap testing step. That step requires data to be received when performing the action.
			Node:
			(type) c
			(layer)1
				Element:p
					Here is the sample JSON for something like a newly created email message, and how it shows up in our user-facing Editor:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"labelIds"
				Element:span
					:
				Element:span
					"DRAFT"
				Element:span
					,
				Element:span
					"id"
				Element:span
					:
				Element:span
					"150f2791b6723cb5"
				Element:span
					,
				Element:span
					"threadId"
				Element:span
					:
				Element:span
					"150f2791b6723cb5"
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					We will parse this sample and provide dropdowns like this to the user:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					By default, we can handle flat dictionaries and dictionaries within dictionaries (via our
				Element:code
					__
					delimiter in keys).
			Node:
			(type) c
			(layer)1
				Element:p
					When the user is inserting fields in the Zap editor, and your API returns no results (
				Element:code
					[]
					) then we will use your hard-coded fallback JSON if it exists.
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					Your hard-coded JSON provided above will
				Element:em
					not
					be run through the Scripting API (either for key enumeration or sample data fallback) so if you use the Scripting API to add or modify fields on top of your normal API response, you'll want to make sure you perform the same manipulations manually before pasting in the JSON above.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Activation
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Developer applications on Zapier can exist in several states. When you first create your application, it will be set to
				Element:code
					private
					.
			Node:
			(type) c
			(layer)1
				Element:p
					When you are ready to publish your app to the world, you have two options:
				Element:code
					Invite-Only
					or
				Element:code
					Global
					.
			Node:
			(type) c
			(layer)1
				Element:p
					You can move applications from one state to another using available options on your developer application dashboard page.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Note:
				Element:em
					If you want make changes to a
				Element:code
					Global
					or
				Element:code
					Invite-Only
					application, the procedure is to clone the application, make the changes to the clone, then
				Element:a
					deploy and replace replace the live application
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Private
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The default status. Visible only to you.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Invite-Only
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Only visible to you and the users you invite. This is perfect if you have a app on Zapier that you'd like to keep out of wider circulation. To invite users you can send emails in bulk through Zapier, or share a direct link.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Pending
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The waiting period before being globally enabled.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Global
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Most vendors who add themselves want to submit for global activation, as this allows you to be placed in both the Zapbook and show up in our standard list for all users to see. Once you submit, expect a response within seven days.
			Node:
			(type) c
			(layer)1
				Element:p
					To find out more about the process to become globally active, read the
					↑ Was this documentation useful?
				Element:a
					activation section
					of the App Lifecycle.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Authentication
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Your API probably has some kind of authentication needs in order for us to talk to it on behalf of a user. Zapier supports the following authentication schemes: Basic Auth, Digest Auth, API Keys or OAuth V2.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Basic Auth
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees in the Web Builder:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					See also:
				Element:a
					Basic auth via CLI
			Node:
			(type) c
			(layer)1
				Element:p
					Classic Basic Auth, where users provide Zapier their username and password to authenticate with your API. This is also the scheme you want to use if your API relies on Basic Auth, but with atypical values for the username and password. For instance, an API that uses an API Key as the username and a dummy value as the password would still want to select Basic Auth for their App.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Digest Auth
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Users will provide Zapier their username and password, and we will handle all the
				Element:a
					nonce
					and quality of protection details automatically.
			Node:
			(type) c
			(layer)1
				Element:p
					See also:
				Element:a
					Digest Auth via CLI
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					API Keys
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Inside the developer platform for devs:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					See also:
				Element:a
					API Key auth via CLI
			Node:
			(type) c
			(layer)1
				Element:p
					Typically, you'll provide your users with an API Key inside your app somewhere. Many times these are provided on the user's settings or accounts page. These keys can be given to Zapier by the user so that we may make authenticated requests to access that user's information on their behalf.
			Node:
			(type) c
			(layer)1
				Element:p
					Define any data which you Zapier must always include with each request as
				Element:a
					auth fields
					. Eg.
				Element:code
					api_key
					,
				Element:code
					account_name
					, etc.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Session-based Auth
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					What the user sees:
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Inside the developer platform for devs:
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					See also:
				Element:a
					Session auth via CLI
			Node:
			(type) c
			(layer)1
				Element:p
					Be sure to tweak which fields are necessary for Zapier successfully attain a valid session with your API. Zapier will then store the credentials for this session until they expire, refreshing them only after encountering a
				Element:code
					401
					, or when specified by the
				Element:code
					get_session_info
					method provided in your
				Element:a
					your custom scripting
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					OAuth
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:ul
					↑ Was this documentation useful?
				Element:li
				Element:a
					Version 1
				Element:em
					(not officially supported)
				Element:li
				Element:a
					Version 2 in the Web Builder
					or
				Element:a
					via the CLI
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Authentication Fields
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Overview
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Authentication fields are simply what you need from the user to get started authenticating their API calls. For example, when a user tries to authenticate your service:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					You can see what it will be powered by a developer set up like:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Additionally, these user-provided variables will be passed in with the
				Element:code
					bundle
					for usage in
				Element:a
					scripting
					. For example, the above screenshots would translate to:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"account_name"
				Element:span
					:
				Element:span
					"myaccount"
				Element:span
					,
				Element:span
					"api_key"
				Element:span
					:
				Element:span
					"123456789"
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					You can use
				Element:a
					Auth Mappings
					to put your Auth Fields to use in Basic Auth, Digest Auth, HTTP headers and query strings.
			Node:
			(type) c
			(layer)1
				Element:p
					Let's look at each of the options you define for a single Auth Field.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Authentication Fields Options
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is somewhat arbitrary but you should pick a good, short key name because you'll need to include it elsewhere in the developer interface as
				Element:code
					{{key}}
					using the
				Element:a
					variable syntax
					. Needs to be at least two characters long, start with an alpha, and only contain
				Element:code
					a-z
					,
				Element:code
					A-Z
					,
				Element:code
					0-9
					or
				Element:code
					_
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
					(you may not need all of these)
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
				Element:code
					api_key
					an API Key which you give to your users somewhere inside your service. Allows Zapier to authenticate on their behalf
				Element:li
				Element:code
					account_name
					an account name which you use to build the API Request URL (perhaps as a subdomain: https://{{account_name}}.example.com/api/v1/)
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Label
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This will show up just above the text input field as a human-readable name. You don't need to be super descriptive here; you can provide more details and information about this field in the Help Text field.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
					API Key, Account Name
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Required
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Pretty easy concept; most all auth fields should be required. You really shouldn't ask for non-essential information as an auth field.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Help Text
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Smaller text which appears under the Label of the field. You can type longer directions here. A common pattern for Auth Field Help Text is to tell the user where in your interface they can find their API Key.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
					The API Key for your account, you can find this by going to your Basecamp Profile page, clicking settings, then API Keys.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Default
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If you specify a default value, the actual field will be pre-filled with this value when the user goes to add a new authentication for your service. If the user clears out a required auth field which had a default set, they will receive an error. Optional fields that are missing a value will use the default every time.
			Node:
			(type) c
			(layer)1
				Element:p
					Most auth fields will not have a default.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					choice_b
					(if you use the choices feature detailed below)
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Static Dropdowns
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					You can create a dropdown-style select box by giving us a comma-separated list of choices. This works well in conjunction with the default value option above.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					choice_a,choice_b,choice_c
					or
				Element:code
					Yesterday, Today, Tomorrow
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					If you would like to provide a label for the raw value of each choice, you can also use the raw|label,raw|label syntax instead.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					1|Option 1,2|Option 2
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Subdomain Format
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If you need the user to supply an account name (or similar) which gets translated into a subdomain (or similar) URL format, we recommend you take advantage of this feature. It helps guide the user with what to type in.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					https://,{{input}},.yourdomain.com/
					will create:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					Note: don't forget the commas!
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Authentication Mappings
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Auth mappings tell us how to interpret what your user provides as usable Basic Auth, Digest Auth, HTTP headers and query strings. Let's use an example where there are two auth fields available to us:
				Element:code
					account_name
					and
				Element:code
					api_key
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
												Node:
												(type) c
												(layer)4
													Element:h4
														Basic Auth
													Element:a
														#
												Node:
												(type) c
												(layer)4
													Element:p
														Your app might use
													Element:code
														api_key
														as the username and password is ignored:
												Node:
												(type) c
												(layer)4
													Element:pre
													Element:span
														{
													Element:span
														"username"
													Element:span
														:
													Element:span
														"{{api_key}}"
													Element:span
														,
													Element:span
														"password"
													Element:span
														:
													Element:span
														"x"
													Element:span
														}
												Node:
												(type) c
												(layer)4
													Element:p
														Or maybe, where
													Element:code
														account_name
														is the username and
													Element:code
														api_key
														is the password:
												Node:
												(type) c
												(layer)4
													Element:pre
													Element:span
														{
													Element:span
														"username"
													Element:span
														:
													Element:span
														"{{account_name}}"
													Element:span
														,
													Element:span
														"password"
													Element:span
														:
													Element:span
														"{{api_key}}"
													Element:span
														}
												Node:
												(type) c
												(layer)4
													Element:p
														Which will automatically create and use a header like:
												Node:
												(type) c
												(layer)4
													Element:p
													Element:code
														Authorization: Basic WkFQSUVSIExPVkVTIFlPVTpYT1hP
												Node:
												(type) c
												(layer)4
													Element:a
												Node:
												(type) c
												(layer)4
													Element:h3
														Digest Auth
													Element:a
														#
												Node:
												(type) c
												(layer)4
													Element:p
														Your app might have
													Element:code
														account_name
														as the username and
													Element:code
														api_key
														as the password:
												Node:
												(type) c
												(layer)4
													Element:pre
													Element:span
														{
													Element:span
														"username"
													Element:span
														:
													Element:span
														"{{account_name}}"
													Element:span
														,
													Element:span
														"password"
													Element:span
														:
													Element:span
														"{{api_key}}"
													Element:span
														}
												Node:
												(type) c
												(layer)4
													Element:p
														We handle the computation of the response, so you don't have to think about realms, nonces, or qop's.
												Node:
												(type) c
												(layer)4
													Element:a
												Node:
												(type) c
												(layer)4
													Element:h3
														API Key Header Auth
													Element:a
														#
												Node:
												(type) c
												(layer)4
													Element:p
														Say your app has two headers called
													Element:code
														X-Account-Name
														and
													Element:code
														X-API-Key
														:
												Node:
												(type) c
												(layer)4
													Element:pre
													Element:span
														{
													Element:span
														"X-Account-Name"
													Element:span
														:
													Element:span
														"{{account_name}}"
													Element:span
														,
													Element:span
														"X-API-Key"
													Element:span
														:
													Element:span
														"{{api_key}}"
													Element:span
														}
												Node:
												(type) c
												(layer)4
													Element:p
														Which will automatically create and use headers like:
												Node:
												(type) c
												(layer)4
													Element:pre
														X-Account-Name: myfancyaccount X-API-Key: 0123456789
												Node:
												(type) c
												(layer)4
													Element:a
												Node:
												(type) c
												(layer)4
													Element:h3
														API Key Query strings
													Element:a
														#
												Node:
												(type) c
												(layer)4
													Element:p
														If your app uses an API key passed as a parameter in the query string, let's call it
													Element:code
														user_key
														:
												Node:
												(type) c
												(layer)4
													Element:pre
													Element:span
														{
													Element:span
														"user_key"
													Element:span
														:
													Element:span
														"{{api_key}}"
													Element:span
														}
												Node:
												(type) c
												(layer)4
													Element:p
														Which will append
														↑ Was this documentation useful?
													Element:code
														?user_key=0123456789
														to the end of a URL.
												Node:
												(type) c
												(layer)4
													Element:span
													Element:a
														Yes
													Element:a
														No
												Node:
												(type) c
												(layer)4
													Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Clone
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Once your app is live (Public or Invite-Only), you'll probably want to make changes to it and add features or fix bugs. While you cannot make changes to a live app, you can
				Element:strong
					clone
					an app and then make changes to the clone.
			Node:
			(type) c
			(layer)1
				Element:p
					To clone your app, click on the
				Element:strong
					Deployment
					tab in your app editor, and click the button
				Element:strong
					Make a Copy of Your App by Cloning
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					A cloned app will begin in Private mode, which allows you to make your edits. If you wish to use the cloned app to replace your previous app (either Global or Invite-Only), you'll want to
					↑ Was this documentation useful?
				Element:a
					deploy a replacement
					.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Data Sources
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					There are four ways Zapier can obtain data from your API.
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
				Element:a
					Polling
					- repeatedly hit a REST endpoint looking for new data.
				Element:li
				Element:a
					Static Webhooks
					- gives the user a URL to enter into your app. Hooks carry the full object.
				Element:li
				Element:a
					REST Hooks
					work similar to static webhooks, but our system handles the subscriptions through your REST API.
				Element:li
				Element:a
					Notification REST Hooks
					are "lightweight" REST Hooks as they only contain a callback URL to retrieve the object.
			Node:
			(type) c
			(layer)1
				Element:p
					Learn more about each type by following the links to the specific sections.
					↑ Was this documentation useful?
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Datetimes
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					For triggers, please supply any date-related fields in an RFC standard of your choosing. We do our best to parse a variety of datetime formats.
			Node:
			(type) c
			(layer)1
				Element:p
					For actions, datetimes are normalized to an ISO-8601 formatted string. For details, see the
				Element:a
					datetime field type
					. An example: a user has a Zap between Wufoo and Mailchimp. The Wufoo "new entry" trigger supplies a UNIX epoch timestamp field. If the user maps the datetime field from Wufoo into Mailchimp, it will be supplied to Mailchimp as a string, formatted like
				Element:code
					2015-03-05T01:00:00
					.
			Node:
			(type) c
			(layer)1
				Element:p
					If you need a different date format (like epoch as int) - you'll need to use our scripting platform to do a conversion.
					↑ Was this documentation useful?
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Deduplication
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					We do the deduplication automatically for you, but you must be mindful of how it works. The important bits are outlined below!
			Node:
			(type) c
			(layer)1
				Element:p
					Deduplication tl;dr:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Provide a unique
				Element:code
					id
					key.
				Element:li
					Sort reverse-chronologically by time created.
			Node:
			(type) c
			(layer)1
				Element:p
					An unfortunate artifact of
				Element:a
					polling
					for new data is that we must deduplicate the results we get back from your API. After all, we don't want to trigger an action multiple times when a newly created item in your API exists in multiple distinct polls.
			Node:
			(type) c
			(layer)1
				Element:p
					For example, say your endpoint returns a list of to-dos:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					7
				Element:span
					,
				Element:span
					"created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:41:54 -0400"
				Element:span
					,
				Element:span
					"list_id"
				Element:span
					:
				Element:span
					1
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"integrate our api with zapier"
				Element:span
					,
				Element:span
					"complete"
				Element:span
					:
				Element:span
					false
				Element:span
					},
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					6
				Element:span
					,
				Element:span
					"created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:41:45 -0400"
				Element:span
					,
				Element:span
					"list_id"
				Element:span
					:
				Element:span
					1
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"get published in zapier library"
				Element:span
					,
				Element:span
					"complete"
				Element:span
					:
				Element:span
					false
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					Every time a new Zap is created or turned on, we make a call to your API to populate our deduplication mechanism. We will cache and store each
				Element:code
					id
					field in our database.
			Node:
			(type) c
			(layer)1
				Element:p
					After this, we will poll at an interval (based on customer's plan) looking for changes against this cached list of
				Element:code
					id
					s.
			Node:
			(type) c
			(layer)1
				Element:p
					Now let's say we created a new to-do:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					8
				Element:span
					,
				Element:span
					"created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:42:09 -0400"
				Element:span
					,
				Element:span
					"list_id"
				Element:span
					:
				Element:span
					1
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"re-do our api to support webhooks"
				Element:span
					,
				Element:span
					"complete"
				Element:span
					:
				Element:span
					false
				Element:span
					},
				Element:span
					}
				Element:span
					"id"
				Element:span
					:
				Element:span
					7
				Element:span
					,
				Element:span
					"created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:41:54 -0400"
				Element:span
					,
				Element:span
					"list_id"
				Element:span
					:
				Element:span
					1
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"integrate our api with zapier"
				Element:span
					,
				Element:span
					"complete"
				Element:span
					:
				Element:span
					false
				Element:span
					},
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					6
				Element:span
					,
				Element:span
					"created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:41:45 -0400"
				Element:span
					,
				Element:span
					"list_id"
				Element:span
					:
				Element:span
					1
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"get published in zapier library"
				Element:span
					,
				Element:span
					"complete"
				Element:span
					:
				Element:span
					false
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					The first to-do with
				Element:code
					id
					equal to
				Element:code
					8
					will be seen as a new item. That particular JSON object will then be passed through to the action in the user's Zap. The
				Element:code
					id
					of the next item (
				Element:code
					7
					) we already know and because we assume the results are sorted in reverse-chronological order (newest first) this is where we stop processing the result.
			Node:
			(type) c
			(layer)1
				Element:p
					Your API must be able to return results in reverse-chronological order.
				Element:a
					Wufoo is a great example
					of an API that supports sorting on any field and direction.
			Node:
			(type) c
			(layer)1
				Element:p
					One other requirement is the
				Element:code
					id
					field should always be supplied and unique among all items in the result.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Custom or multiple ID fields
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					What if the items your API returns do not have an
				Element:code
					id
					field? Or how would you go about adding a
				Element:em
					Updated to-do
					trigger to our to-do app? In both cases you'll use
				Element:a
					scripting
					to modify the API response.
			Node:
			(type) c
			(layer)1
				Element:p
					Let's assume your to-do API has an endpoint to return to-dos sorted by
				Element:code
					updatedAt
					in descending direction. This is how you would use the scripting post poll trigger method:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					var
				Element:span
					Zap
				Element:span
					=
				Element:span
					{
				Element:span
					TRIGGER_KEY_post_poll
				Element:span
					:
				Element:span
					function
				Element:span
					(
				Element:span
					bundle
				Element:span
					)
				Element:span
					{
				Element:span
					var
				Element:span
					items
				Element:span
					=
				Element:span
					JSON
				Element:span
					.
				Element:span
					parse
				Element:span
					(
				Element:span
					bundle
				Element:span
					.
				Element:span
					response
				Element:span
					.
				Element:span
					content
				Element:span
					);
				Element:span
					items
				Element:span
					.
				Element:span
					forEach
				Element:span
					(
				Element:span
					function
				Element:span
					(
				Element:span
					item
				Element:span
					)
				Element:span
					{
				Element:span
					item
				Element:span
					.
				Element:span
					originalId
				Element:span
					=
				Element:span
					item
				Element:span
					.
				Element:span
					id
				Element:span
					;
				Element:span
					item
				Element:span
					.
				Element:span
					id
				Element:span
					=
				Element:span
					item
				Element:span
					.
				Element:span
					id
				Element:span
					+
				Element:span
					'-'
				Element:span
					+
				Element:span
					item
				Element:span
					.
				Element:span
					updatedAt
				Element:span
					;
				Element:span
					});
				Element:span
					return
				Element:span
					items
				Element:span
					;
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					Notice how we preserve the original value before setting
				Element:code
					id
					to a new combined value that is unique for every update of a to-do.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Re-order items
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					What if your API cannot order its results in reverse-chronological order? Again scripting can help you deal with this.
			Node:
			(type) c
			(layer)1
				Element:p
					Depending on your API it is most likely you will need to use the scripting poll trigger method. This will let you handle the
				Element:a
					request(s) to your API
					.
			Node:
			(type) c
			(layer)1
				Element:p
					One possible scenario could be:
			Node:
			(type) c
			(layer)1
				Element:ol
					↑ Was this documentation useful?
				Element:li
					Fetch the first page, containing the oldest items, but also the total number of pages.
				Element:li
					Fetch the last page and reverse the order of the items before returning it.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Deploy
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					If your app is still private, read the
				Element:a
					deploy lifecycle doc
					on how to make it public! This doc is for deploying updated code to an already public or Invite-Only app.
			Node:
			(type) c
			(layer)1
				Element:p
					Once your app is live (Public or Invite-Only), you'll probably want to make changes to it and add features or fix bugs. While you cannot make changes to a live app, you can
				Element:strong
					clone
					an app and then make changes to the clone.
			Node:
			(type) c
			(layer)1
				Element:p
					The first step is to click on the
				Element:strong
					Deployment
					tab, and click the button
				Element:strong
					Make a Copy of Your App by Cloning
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					In the new/cloned app, make your changes. Be sure to leave this app in the
				Element:strong
					Private
					status!
			Node:
			(type) c
			(layer)1
				Element:p
					When you've finished testing your changes, and are ready to update the existing/public app, go into the new/cloned app, click on the
				Element:strong
					Deployment
					tab, and click the button to
				Element:strong
					Deploy and Replace an Existing App
					.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Once you have deployed your new/cloned app to replace an existing app, all zaps will be updated to use this new app. Read on for important notes on handling breaking app changes.
			Node:
			(type) c
			(layer)1
				Element:p
					A screen will ask you which app you want to replace. Select the existing/live app:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					The system will run an audit and show you the results:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					In the screenshot you can see an error for
				Element:strong
					New Item
					, with the error of
				Element:em
					Polling triggers should always have sample data
					. This simply means you need to provide a sample result for a polling trigger.
			Node:
			(type) c
			(layer)1
				Element:p
					Usually you can just make some changes and ensure there is a symmetry between old and new versions of the app. If there is a breaking changes that resolves a bug, please
				Element:a
					contact us
					and we'll perform a manual deployment.
			Node:
			(type) c
			(layer)1
				Element:p
					There are a number of situations where making changes in your app may cause the existing Live Zaps to stop working. If any of those situations are detected, the system will not allow you to complete the deploy/replace process. Please visit
				Element:a
					this page of Deploy Errors
					and try a workaround.
			Node:
			(type) c
			(layer)1
				Element:p
					If your app is Invite-Only, your cloned app's OAuth redirect URI will become active upon migration (it will contain a new ID #), and the old OAuth redirect URI will no longer function.
				Element:strong
					Please plan accordingly.
					Contact us for a solution to this problem if it is difficult to manage - we can set a permanent redirect URI for your app.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					How to Handle Breaking Changes
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The best approach is to copy the Triggers/Actions/Searches you want to update. Mark the originals hidden and append "(Legacy)" to their labels. On the copies, make the needed updates (it also helps to update their keys to something instructive, like append "_v2" to the original key). Once you deploy, new Zaps will only have the copies available and old Zaps will continue to work unaffected.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Deploy in process
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If all goes well and you have no warnings when trying to deploy, a deploy process will start asynchronously and you can come back to the
					↑ Was this documentation useful?
				Element:strong
					Deployment
					tab to check on its progress.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Monitoring
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					You can access Monitoring by clicking the "Monitoring" tab on your App's details.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					This section is meant to allow you to quickly understand if your app is OK or not, by checking and comparing types of events (ideally you want to see a lot of 2xx - green, and no errors - red).
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					NOTE:
					The monitoring information is less useful for services/endpoints that consistently return an
				Element:code
					HTTP 200
					status, and contain a payload with an error message.
			Node:
			(type) c
			(layer)1
				Element:p
					If you have access to it, you can click on a data point in the chart and get details about up to 500 events for the chosen period.
			Node:
			(type) c
			(layer)1
				Element:p
					If you have too many events, you can use the filters on the right side to filter which events will be displayed on the list once you click a data point.
			Node:
			(type) c
			(layer)1
				Element:p
					This is useful for mainly for debugging purposes.
					↑ Was this documentation useful?
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Dynamic Dropdowns
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Sometimes, API endpoints require clients to specify a parent object in order to create or access the child resources. Imagine having to specify a company id in order to get a list of employees for that company. Since people don't speak in auto-incremented ID's, it is necessary that Zapier offer a simple way to select that parent using human readable handles.
			Node:
			(type) c
			(layer)1
				Element:p
					Our solution is to present users a dropdown that is populated by making a live API call to fetch a list of
				Element:em
					parent
					objects. We call these special dropdowns
				Element:strong
					dynamic dropdowns
					.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Tip: We used to call the dynamic dropdowns "prefills"!
			Node:
			(type) c
			(layer)1
				Element:p
					Here is what a user sees as a dynamic dropdown:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					In order for a dynamic dropdown to work, we must have a working
				Element:a
					trigger
					set up for the parent object. Zapier will query for that dynamic dropdown, parse out an identifier and a human readable handle for each record, and then offer the user a dropdown. Once they make a selection, we store the identifier for use later when reading or writing child objects.
			Node:
			(type) c
			(layer)1
				Element:p
					The dynamic dropdown syntax is split into three parts:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Which trigger is this dynamic dropdown referring to?
				Element:li
					Which piece of data is the unique identifier?
				Element:li
					Which piece of data is a human readable representation?
			Node:
			(type) c
			(layer)1
				Element:p
					We combine those into one field:
				Element:code
					TRIGGERKEY.identifier_key.human_readable_key
					.
			Node:
			(type) c
			(layer)1
				Element:p
					For example, let's say you have a trigger called Project which offers the following data (remember, triggers are expected to return a list of JSON objects with an ID field):
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					4287243
				Element:span
					,
				Element:span
					"owner_id"
				Element:span
					:
				Element:span
					4632
				Element:span
					,
				Element:span
					"date_created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:41:54 -0400"
				Element:span
					,
				Element:span
					"title"
				Element:span
					:
				Element:span
					"My secret project!"
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"It's a Facebook for dogs!"
				Element:span
					}
				Element:span
					...
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					You want to let users read just the messages from that project as a trigger. As you are making the
				Element:strong
					message trigger
					you'd need to create a
				Element:code
					project
				Element:a
					trigger field
					with the following dynamic dropdown value:
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					new_project.id.title
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Note:
				Element:code
					new_project
					is a fictional key for the Project trigger. You'll set your specific trigger key when you create your trigger.
				Element:code
					id
					is the identifier from the above project data. The human readable representation key
				Element:code
					title
					is located there as well.
			Node:
			(type) c
			(layer)1
				Element:p
					Notice that a dynamic dropdown is really nothing more than a
					↑ Was this documentation useful?
				Element:a
					trigger field
					/
				Element:a
					action field
					that is populated by another trigger.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Combining Multiple Dynamic Dropdowns
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					There are times where a Dynamic Dropdown may need to use a value (or ID) that is selected from a previous or dependent parent Dynamic Dropdown. An example is a task-planning service that has
				Element:strong
					Projects
					, and within each of those projects are
				Element:strong
					Tasks
					. To select a
				Element:strong
					Task
					, a
				Element:strong
					Project
					must first be selected, like this:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					There are three
				Element:strong
					Triggers
					involved here:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					A hidden Trigger that supplies the list of
				Element:strong
					Projects
					.
				Element:li
					A hidden Trigger that supplies the list of
				Element:strong
					Tasks
					for a specific Project.
				Element:li
					A visible Trigger that contains a pair of
				Element:strong
					Trigger Fields
					, which pull their values from the hidden triggers.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					The first trigger
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Here's the definition for the first
				Element:strong
					Trigger
					, named
				Element:strong
					List Projects
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
				Element:br
					This trigger doesn't need any
				Element:strong
					Trigger Fields
					, so leave that empty.
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					The second trigger
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Here's the definition for the second
				Element:strong
					Trigger
					, named
				Element:strong
					Tasks in a Project
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
				Element:br
					This trigger doesn't need any
				Element:strong
					Trigger Fields
					either, so leave that empty.
				Element:br
					In the
				Element:strong
					Polling URL
					we'll use a
				Element:strong
					key
					called
				Element:code
					project
					(which will be filled in by the previous Dynamic Dropdown), but it's a "leap of faith", because it relies on the third trigger to define the key called
				Element:code
					project
					.
				Element:br
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					The third trigger
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Here's the definition for the third
				Element:strong
					Trigger
					, that uses the previous two as
				Element:strong
					Dynamic Dropdowns
					:
			Node:
			(type) c
			(layer)1
				Element:p
					The important part is that the
				Element:strong
					Trigger Fields
					specifies the keys used in the previous
				Element:strong
					Triggers
					to use for the
				Element:strong
					Dynamic Dropdowns
					:
				Element:img
					When users create a Zap for this trigger, they'll be shown the two Dynamic Dropdowns, and the value from the first one will be stored within
				Element:code
					trigger_fields.project
					, and the second in
				Element:code
					trigger_fields.task
					.
			Node:
			(type) c
			(layer)1
				Element:p
					This results in the
				Element:code
					bundle.trigger_fields
					to contain these two values:
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Which can either be specified within the
					↑ Was this documentation useful?
				Element:strong
					Polling: URL Route
					of the third trigger:
				Element:br
				Element:img
				Element:br
					Or can be used within the
				Element:a
					Scripting
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Field Types
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The following is a list of the field types we use internally. Normally, you'd choose one of these fields when creating your
				Element:a
					action fields
					or
				Element:a
					trigger fields
					via the type dropdown:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					However, if you're using
				Element:a
					Custom Fields
					you might want to know the available field types. The key column corresponds to the
				Element:code
					type
					key found in the code example here:
				Element:a
					Action Fields (Custom)
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Unicode
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Unicode fields are essentially one-line text fields that can support unicode characters. There is no coercion done for this type.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Unicode fields are represented by a
				Element:code
					type: unicode
					key.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Textarea
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Think of this as a multi-line unicode field. It's really only used to give the user a textarea in the UI instead of a one-line input field. There is no coercion done for this type.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Textarea fields are represented by a
				Element:code
					type: text
					. key
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Integer
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Suitable for whole integer numbers, we'll coerce any text down into an integer by stripped non-numeric values from the string. A negative sign (-) in front is also allowed.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Integer fields are represented by a
				Element:code
					type: int
					key.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Float
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Like integers, this will coerce any text down to a floating point number with the addition of allowed characters like
				Element:code
					.
					and
				Element:code
					,
					.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Float fields are represented by a
				Element:code
					type: decimal
					key.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Boolean
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We apply some natural language parsing to try and coerce any text into
				Element:code
					True
					or
				Element:code
					False
					. This UI field is also replaced with a dropdown allowing the user to specifically pick "Yes" or "No" explicitly.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Boolean fields are represented by a
				Element:code
					type: bool
					key.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					DateTime
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Our most complex coercion. We'll attempt to convert any given value into an ISO-8601 formatted string. The parser is quite robust, supporting epoch timestamps, ISO-8601 and even natural language parsing! You can use
				Element:code
					moment.js
					via
				Element:a
					Scripting
					to parse and replace if your servers expect a different format sent to it.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					DateTime fields are represented by a
				Element:code
					type: datetime
					key.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Dictionary/Object
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is a fairly complex shortcut to a widget that allows a user to provide a series of key/value pairs, perfect for providing completely unstructured and custom metadata (do
				Element:strong
					not
					use this if your API provide definitions for that metadata, look into custom fields instead!).
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Dictionary/Object fields are represented by a
				Element:code
					type: dict
					key.
			Node:
			(type) c
			(layer)1
				Element:p
					There are also a few other special things, related to types, you can do.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Static Dropdown
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					You can provide a
				Element:code
					choices
					array which will be mapped automatically into a dropdown in the Zap Editor. In the developer UI you should simply provide us with a hard-coded list of comma-separated values for the "choices" option when defining a field. If you're using
				Element:a
					scripting
					, you'll want to provide this array to us manually. Here is a code sample and what it looks like:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"type"
				Element:span
					:
				Element:span
					"unicode"
				Element:span
					,
				Element:span
					"key"
				Element:span
					:
				Element:span
					"color"
				Element:span
					,
				Element:span
					"label"
				Element:span
					:
				Element:span
					"Label"
				Element:span
					,
				Element:span
					"help_text"
				Element:span
					:
				Element:span
					"Pick a color label to apply to the card."
				Element:span
					,
				Element:span
					"choices"
				Element:span
					:
				Element:span
					[
				Element:span
					"none"
				Element:span
					,
				Element:span
					"green"
				Element:span
					,
				Element:span
					"yellow"
				Element:span
					,
				Element:span
					"orange"
				Element:span
					,
				Element:span
					"red"
				Element:span
					,
				Element:span
					"purple"
				Element:span
					,
				Element:span
					"blue"
				Element:span
					]
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					You can also provide an object with
				Element:code
					key
					and
				Element:code
					value
					for choices if you like.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Lists
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Say you wanted to allow the user to specify multiple values for a single field. Maybe, a list of tags to apply or a list of email addresses to send to. You can use our
				Element:code
					list
					feature to enable "+" and "-" buttons in the Zap Editor which users can use to specify more than one value.
				Element:code
					list
					fields can be any
				Element:code
					type
					except
				Element:code
					dict
					.
			Node:
			(type) c
			(layer)1
				Element:p
					You can make a field a list by checking the appropriate box in the UI. For custom fields, you can use
				Element:a
					Scripting
					to alter the field definition to include
				Element:code
					list: true
					like this:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"type"
				Element:span
					:
				Element:span
					"unicode"
				Element:span
					,
				Element:span
					"key"
				Element:span
					:
				Element:span
					"to"
				Element:span
					,
				Element:span
					"label"
				Element:span
					:
				Element:span
					"To"
				Element:span
					,
				Element:span
					"help_text"
				Element:span
					:
				Element:span
					"Who will this email be sent to?"
				Element:span
					,
				Element:span
					"list"
				Element:span
					:
				Element:span
					true
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:img
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Files
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Zapier supports some limited file operations via both triggers and actions, though they behave a bit differently depending on what you want to do. At a high level, this is what you can expect:
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Triggers via URLs/Dehydration
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					This is how you'd surface a file hosted by your app, so other apps can consume it.
			Node:
			(type) c
			(layer)1
				Element:p
					If your files aren't private (IE: they have a public route), just provide the URL in the normal payload (right alongside
				Element:code
					id
					,
				Element:code
					name
					, etc.). Our system is smart enough to download public URLs when they get used like a file!
			Node:
			(type) c
			(layer)1
				Element:p
					However, if the files are behind authentication, you can define a route for us to retrieve the file at some time in the future and we'll attempt the normal style of authentication:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					var
				Element:span
					Zap
				Element:span
					=
				Element:span
					{
				Element:span
					your_trigger_post_poll
				Element:span
					:
				Element:span
					function
				Element:span
					(
				Element:span
					bundle
				Element:span
					)
				Element:span
					{
				Element:span
					var
				Element:span
					records
				Element:span
					=
				Element:span
					JSON
				Element:span
					.
				Element:span
					parse
				Element:span
					(
				Element:span
					bundle
				Element:span
					.
				Element:span
					response
				Element:span
					.
				Element:span
					content
				Element:span
					);
				Element:span
					return
				Element:span
					_
				Element:span
					.
				Element:span
					map
				Element:span
					(
				Element:span
					records
				Element:span
					,
				Element:span
					function
				Element:span
					(
				Element:span
					record
				Element:span
					)
				Element:span
					{
				Element:span
					// if you just do url, we'll include any standard authentication headers
				Element:span
					record
				Element:span
					.
				Element:span
					file
				Element:span
					=
				Element:span
					z
				Element:span
					.
				Element:span
					dehydrateFile
				Element:span
					(
				Element:span
					'https://yoursite.com/files/download/'
				Element:span
					+
				Element:span
					record
				Element:span
					.
				Element:span
					id
				Element:span
					);
				Element:span
					return
				Element:span
					record
				Element:span
					;
				Element:span
					});
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					You can also define a more specific request if there is more data you need to provide to activate the download, like a special key or checksum:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					var
				Element:span
					Zap
				Element:span
					=
				Element:span
					{
				Element:span
					your_trigger_post_poll
				Element:span
					:
				Element:span
					function
				Element:span
					(
				Element:span
					bundle
				Element:span
					)
				Element:span
					{
				Element:span
					var
				Element:span
					records
				Element:span
					=
				Element:span
					JSON
				Element:span
					.
				Element:span
					parse
				Element:span
					(
				Element:span
					bundle
				Element:span
					.
				Element:span
					response
				Element:span
					.
				Element:span
					content
				Element:span
					);
				Element:span
					return
				Element:span
					_
				Element:span
					.
				Element:span
					map
				Element:span
					(
				Element:span
					records
				Element:span
					,
				Element:span
					function
				Element:span
					(
				Element:span
					record
				Element:span
					)
				Element:span
					{
				Element:span
					// if you provide the full request, we will NOT include
				Element:span
					// any standard authentication headers
				Element:span
					var
				Element:span
					url
				Element:span
					=
				Element:span
					'https://yoursite.com/files/download/'
				Element:span
					+
				Element:span
					record
				Element:span
					.
				Element:span
					id
				Element:span
					;
				Element:span
					record
				Element:span
					.
				Element:span
					file
				Element:span
					=
				Element:span
					z
				Element:span
					.
				Element:span
					dehydrateFile
				Element:span
					(
				Element:span
					url
				Element:span
					,
				Element:span
					{
				Element:span
					method
				Element:span
					:
				Element:span
					'post'
				Element:span
					,
				Element:span
					headers
				Element:span
					:
				Element:span
					{
				Element:span
					'X-Download-Key'
				Element:span
					:
				Element:span
					record
				Element:span
					.
				Element:span
					key
				Element:span
					}
				Element:span
					},
				Element:span
					{
				Element:span
					name
				Element:span
					:
				Element:span
					record
				Element:span
					.
				Element:span
					fileName
				Element:span
					,
				Element:span
					// if blank we will guess/inspect!
				Element:span
					length
				Element:span
					:
				Element:span
					record
				Element:span
					.
				Element:span
					size
				Element:span
					// if blank we will guess/inspect!
				Element:span
					});
				Element:span
					return
				Element:span
					record
				Element:span
					;
				Element:span
					});
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					And we'll handle the rest!
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Actions via Multipart
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					This is how you'd accept binary data to be uploaded to your app, the data is coming from some other app.
			Node:
			(type) c
			(layer)1
				Element:p
					Downloading files is a little simpler than uploading them, so files in actions is a bit more involved. By default we attempt multipart uploading and include the original JSON right alongside, but you can (of course) tweak this with the developer platform.
			Node:
			(type) c
			(layer)1
				Element:p
					Let's assume your API can accept JSON as well as JSON + multipart for attachments, if you set up this action:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					You can expect this request to be sent by default (no scripting required at all):
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://yoursite.com/files/upload Content-Type: multipart/form-data; boundary=f94636b7375c4a37862029d4dc8bafe7 --f94636b7375c4a37862029d4dc8bafe7 Content-Disposition: form-data; name="data" Content-Type: application/json; charset=utf-8 {"path": "/user/provided/path", "delete_date": "2014-10-10T13:59:36"} --f94636b7375c4a37862029d4dc8bafe7 Content-Disposition: form-data; name="file_to_upload"; filename="user-provided-file.pdf" Content-Type: application/pdf <BINARY DATA HERE> --f94636b7375c4a37862029d4dc8bafe7--
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					The
				Element:code
					name="data"
					key for the JSON subtype in
				Element:code
					multipart/form-data
					is the default, though the rest of the multipart files will respect your action field keys.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Limited Customization Via Scripting
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If you have some other method of uploading files, you'll need to break out the scripting platform. Probably the most common way to tweak the upload is with the classic
				Element:code
					pre_write
					method.
			Node:
			(type) c
			(layer)1
				Element:p
					A popular alternative pattern is likely just a pure
				Element:code
					multipart/form-data
					, no JSON at all. We support that just fine, just remove the
				Element:code
					Content-Type
					and return an object as
				Element:code
					request.data
					:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					var
				Element:span
					Zap
				Element:span
					=
				Element:span
					{
				Element:span
					your_action_pre_write
				Element:span
					:
				Element:span
					function
				Element:span
					(
				Element:span
					bundle
				Element:span
					)
				Element:span
					{
				Element:span
					// bundle.request.files is an object of strings: arrays
				Element:span
					// bundle.request.files.file_to_upload is an array:
				Element:span
					// * first item is the filename, if any
				Element:span
					// * second item is a zapier.com endpoint that will stream the file
				Element:span
					// * third item is the mimetype, if any
				Element:span
					bundle
				Element:span
					.
				Element:span
					request
				Element:span
					.
				Element:span
					headers
				Element:span
					[
				Element:span
					'Content-Type'
				Element:span
					]
				Element:span
					=
				Element:span
					'application/x-www-form-urlencoded'
				Element:span
					;
				Element:span
					// leave request data as object, not string!
				Element:span
					bundle
				Element:span
					.
				Element:span
					request
				Element:span
					.
				Element:span
					data
				Element:span
					=
				Element:span
					JSON
				Element:span
					.
				Element:span
					parse
				Element:span
					(
				Element:span
					bundle
				Element:span
					.
				Element:span
					request
				Element:span
					.
				Element:span
					data
				Element:span
					);
				Element:span
					// we will mix request.data and request.files together
				Element:span
					return
				Element:span
					bundle
				Element:span
					.
				Element:span
					request
				Element:span
					;
				Element:span
					// let zapier complete it
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					That pure
				Element:code
					multipart/form-data
					raw request will now look like this:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://yoursite.com/files/upload Content-Type: multipart/form-data; boundary=0c61d2f9bd1a4675a2db6afe21f230f1 --0c61d2f9bd1a4675a2db6afe21f230f1 Content-Disposition: form-data; name="path" /user/provided/path --0c61d2f9bd1a4675a2db6afe21f230f1 Content-Disposition: form-data; name="delete_date" 2014-10-10T13:59:36 --0c61d2f9bd1a4675a2db6afe21f230f1 Content-Disposition: form-data; name="file_to_upload"; filename="user-provided-file.pdf" Content-Type: application/pdf <BINARY DATA HERE> --0c61d2f9bd1a4675a2db6afe21f230f1--
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					All name keys respect the keys provided.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Advanced Streaming via Scripting
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					At this time we do no support advanced streaming of files via the scripting platform (for example, uploading a file to receive an attachment ID that gets mixed into the normal JSON for POSTing). We may support that in the future, please send us an
					↑ Was this documentation useful?
				Element:a
					email
					if you have questions!
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Migration
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The old name for what we now call a Deploy. Check out the
					↑ Was this documentation useful?
				Element:a
					deploy section
					for details.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Notification REST Hooks
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Below is the same pattern as our
				Element:a
					REST Hooks
					, but with a twist (and an extra step!). Instead of delivering the payload with each hook, it just delivers a resource URL where the payload resides. This helps us move big requests into a queue with everything else which lets us batch bigger requests. The URL can be one-time use or time sensitive as well.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Your Checklist
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					enumerate the events you'd like to make available as triggers
				Element:li
					create a
				Element:em
					subscribe
					REST endpoint for hooks. For example:
				Element:code
					POST /api/hooks
				Element:li
					when each event happens, loop over and notify each active subscription (or batch events of same type)
				Element:li
					respect
				Element:code
					410
					responses on payload delivery and remove subscriptions
				Element:li
					create a
				Element:em
					unsubscribe
					REST endpoint for hooks. For example:
				Element:code
					DELETE /api/hooks/:id
			Node:
			(type) c
			(layer)1
				Element:p
					Read on for a step by step through the endpoints involved...
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 1: Subscribe
				Element:small
				Element:em
					(a call from Zapier to your app)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					POST <subscribe_endpoint>
				Element:span
					\
					-H Authenticated: Somehow
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					'{"target_url": "https://hooks.zapier.com/<unique_target_url>",
				Element:span
					"event": "user_created"}'
			Node:
			(type) c
			(layer)1
				Element:p
					This endpoint reuses whatever auth standard you have across the rest of your API (IE: Basic Auth, API Key, OAuth2, etc...). We'd send along a
				Element:strong
					unique
					,
				Element:strong
					auto-generated
					subscription URL and the event we'd like to subscribe to. These three items would be persisted on your backend (the authenticated user, target_url, and event).
				Element:strong
					A subscription is created when a user turns their Zap on.
			Node:
			(type) c
			(layer)1
				Element:p
					If you prefer, you can modify this request to provide additional information (like further filtering or other metadata) via our
				Element:code
					pre_subscribe
					scripting method.
			Node:
			(type) c
			(layer)1
				Element:p
					On a successful subscribe, return a
				Element:code
					201
					status code. You should store data about the hook you just created via the
				Element:code
					post_subscribe
					scripting method (return an object like
				Element:code
					{"id": 1234}
					). You'll need this data later to unsubscribe, unless you use the subscription URL as the unique identifier, which is uncommon).
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Generally, subscription URLs should be unique. Return a
				Element:code
					409
					status code if this criteria isn't met (IE: there is a uniqueness conflict).
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 2: Sending Hooks
				Element:small
				Element:em
					(a call from your app to Zapier)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://hooks.zapier.com/<unique_target_url>
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					{
				Element:span
					"resource_url"
					:
				Element:span
					"<resources_url>"
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					This hook must include a
				Element:code
					resource_url
					or we will not perform a followup GET and thus Zaps will not trigger. If you are currently sending an
				Element:code
					id
					, but not a
				Element:code
					resource_url
					, you can modify the trigger's
				Element:code
					catch_hook
					in scripting to add a
				Element:code
					resource_url
					key that uses this
				Element:code
					id
					.
			Node:
			(type) c
			(layer)1
				Element:p
					On a successful hook, we'll return a
				Element:code
					200
					status code, content is irrelevant.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					If Zapier responds with a
				Element:code
					410
					status code you should immediately remove the subscription to the failing hook (unsubscribe). Additionally, excessive failures (multiple
				Element:code
					4xx
					or
				Element:code
					5xx
					failures) can be handled at your discretion. It is the clients responsibility to resubscribe if needed after failures.
				Element:p
					The maximum hook size is 100MB. Any payloads that exceed this limit will see a
				Element:code
					413
					status code.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 3: Consuming
				Element:small
				Element:em
					(a call from Zapier to your app)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					GET <resources_url>
				Element:span
					\
					-H Authenticated: Somehow
				Element:span
					\
					-H Content-Type: application/json
			Node:
			(type) c
			(layer)1
				Element:p
					This is an old fashioned REST hit to a standard endpoint, it requires the same authentication as the rest of the API. It can return a list or a single object.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:em
					If you don't want to perform this extra step, look at
				Element:a
					REST Hooks
					!
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 4: Unsubscribe
				Element:small
				Element:em
					(a call from Zapier to your app)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					DELETE <unsubscribe_endpoint>
				Element:span
					\
					-H Authenticated: Somehow
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d <content built/omitted in pre_unsubscribe scripting method>
			Node:
			(type) c
			(layer)1
				Element:p
					If you've properly stored identification data about the hook (like its unique ID) from the
				Element:code
					post_subscribe
					scripting method, you should use our
				Element:code
					pre_unsubscribe
					scripting method to formulate the DELETE call. In that call you have access to your previously stored data under the
				Element:code
					bundle.subscribe_data
					variable.
				Element:strong
					Unsubscribing occurs when a user turns their Zap off.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:a
					Some example code is provided to make this as easy as possible.
					A heads up: you will need to use that code if you intend to do a DELETE call. You'll be able to access
				Element:code
					bundle.subscribe_data
					to build the URL in
				Element:code
					pre_unsubscribe
					. The default behavior is slightly different and listed below.
			Node:
			(type) c
			(layer)1
				Element:p
					However, the
				Element:strong
					current default
					does not perform a DELETE. For example, if you omit the
				Element:code
					pre_unsubscribe
					function entirely, we will attempt a default unsubscribe call:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST <unsubscribe_endpoint>
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					'{"target_url": "https://hooks.zapier.com/<unique_target_url>"}'
			Node:
			(type) c
			(layer)1
				Element:p
					On a successful unsubscribe, return a
				Element:code
					200
					status code, content is irrelevant.
			Node:
			(type) c
			(layer)1
				Element:p
					It is worth remembering that the subscription URL should effectively be unique (this could be enforced by your app as well) which also allows us to clean up unrecognized hooks (we also recommend not requiring authentication for such an endpoint).
					↑ Was this documentation useful?
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					OAuth V1
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The flow we respect matches
				Element:a
					Twitter's
					and
				Element:a
					Trello's
					implementation of the 3-legged oauth flow.
			Node:
			(type) c
			(layer)1
				Element:p
					Note that OAuth v1 is not officially support on Zapier; we highly recommend using OAuth 2 if possible!
			Node:
			(type) c
			(layer)1
				Element:p
					That being said, with OAuth v1 having been a popular authentication mechanism found on the web, we have a sample implementation if you want to try it, respecting OAuth v1 "revision a".
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Initial Setup:
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					First, you'll need to select
				Element:code
					OAuth 1
					as your auth type, and then provide the required parameters:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					Capture extra data from token response
			Node:
			(type) c
			(layer)1
				Element:p
					If your app returns extra data through the token response (user id for example) you can grab those extra parameters using the
				Element:strong
					Extra Requested Fields
					option.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					How we authenticate with your OAuth service
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We attempt a 3 legged OAuth 1 process that has 3 high level steps:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					Obtain temporary oauth_token and oauth_secret from your app
				Element:li
					Get user to authorize Zapier access to your app
				Element:li
					Exchange the temporary oauth_token for an authorized oauth_token
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					1. Requesting Temporary Credentials From Your App:
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					When a user goes to add a new account for your app, we make a request behind-the-scenes to ask your app for a request token and secret. Your app should respond back with a valid
				Element:code
					oauth_token
					and
				Element:code
					oauth_token_secret
					. Additionally, our request contains an
				Element:code
					oauth_callback
					URL that your app will use in a later step.
			Node:
			(type) c
			(layer)1
				Element:p
					The signed POST request to your application's
				Element:code
					request_token_url
					will look like this:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://example.com/api/1.0/oauth/request_token Authorization: OAuth oauth_nonce="ZAPIER-GENERATED-NONCE", oauth_callback="ZAPIER-OAUTH-CALLBACK", oauth_signature_method="HMAC-SHA1", oauth_timestamp="ZAPIER-GENERATED-TIMESTAMP", oauth_consumer_key="<Your consumer key>", oauth_signature="ZAPIER-GENERATED-SIGNATURE", oauth_version="1.0"
			Node:
			(type) c
			(layer)1
				Element:p
					Your app should validate the request and return with the temporary response token, like so:
			Node:
			(type) c
			(layer)1
				Element:pre
					oauth_token_secret=TEMP-OAUTH-TOKEN-SECRET&oauth_token=TEMP-OAUTH-TOKEN&oauth_callback_confirmed=true
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					2. Redirecting the User to Your App:
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					With token in hand, we redirect the user to the
				Element:code
					authorization_url
					you provided, so that they can grant access to Zapier.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:pre
					302 https://example.com/api/v1/oauth/authenticate?oauth_token=<oauth_token>
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					3. Redirecting the User Back to Zapier:
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					After the user clicks allow, your app redirects the user to
				Element:code
					oauth_callback
					(from Step 1), along with an
				Element:code
					oauth_verifier
					parameter in the query string.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:code
					302 <oauth_callback>?oauth_verifier=<oauth_verifier>
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					4. Exchanging Temporary Credentials for Token Credentials:
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We use that
				Element:code
					oauth_verifier
					to make a POST to the
				Element:code
					access_token_url
					you provided.
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://example.com/api/1.0/oauth/access_token
				Element:span
					\
					-H Accept: application/json
				Element:span
					\
					-d
				Element:span
					'
				Element:span
					consumer_key
				Element:span
					=
					<consumer_key>
				Element:span
					&
				Element:span
					consumer_secret
				Element:span
					=
					<consumer_secret>
				Element:span
					&
				Element:span
					oauth_verifier
				Element:span
					=
					<oauth_verifier>
				Element:span
					&
				Element:span
					oauth_token
				Element:span
					=
					<oauth_token>
				Element:span
					&
				Element:span
					oauth_token
				Element:span
					=
					<oauth_token_secret>
			Node:
			(type) c
			(layer)1
				Element:p
					Your service should then provide an access_token and access_token_secret, along with any extra parameters that you may have included in the optional
				Element:em
					Capture extra data from token response
					step.
			Node:
			(type) c
			(layer)1
				Element:p
					While we ask for a JSON response, the response can be JSON, XML or query string encoded. For example, any of the below are valid responses:
			Node:
			(type) c
			(layer)1
				Element:p
					With
				Element:code
					Content-Type: application/json
					:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"oauth_token"
				Element:span
					:
				Element:span
					"1234567890abcdef"
				Element:span
					,
				Element:span
					"oauth_token_secret"
				Element:span
					:
				Element:span
					"1234567890abcdef"
				Element:span
					,
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					With
				Element:code
					Content-Type: application/xml
					:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					<AnyRootElem>
				Element:span
					<oauth_token>
					1234567890abcdef
				Element:span
					</oauth_token>
				Element:span
					<oauth_token_secret>
					1234567890abcdef
				Element:span
					</oauth_token_secret>
				Element:span
					</AnyRootElem>
			Node:
			(type) c
			(layer)1
				Element:p
					With
				Element:code
					Content-Type: text/plain
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:code
					oauth_token=1234567890abcdef&oauth_token_secret=1234567890abcdef
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					5. Using the Token Credentials
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We sign all requests using your secret and the new
				Element:code
					oauth_token
					and
				Element:code
					oauth_token_secret
					. We're talking standard HMAC-SHA1, RSA is not supported. However, you can use
				Element:a
					scripting
					to modify request parameters (including headers) as you see fit.
			Node:
			(type) c
			(layer)1
				Element:p
					For example, if a POST request to your API expects
				Element:code
					Content-Type:application/x-www-url-form-encoded
					instead of the standard
				Element:code
					application/x-www-form-urlencoded
					then you can use a custom script to modify the request that we make. In an app with a trigger
				Element:code
					create_ticket
					the Scripting API would look like so:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:pre
					var Zap = { create_ticket_pre_write: function(bundle) { bundle.request.headers['Content-Type'] = 'application/x-www-url-form-encoded'; return bundle.request; } }
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Example:
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We highly recommend looking at each of
					↑ Was this documentation useful?
				Element:a
					Bitbucket's
					,
				Element:a
					Twitter's
					and
				Element:a
					Trello's
					authentication documentation for some great examples of how OAuth 1a can be implemented. Our system is designed to match their industry standard implementation pattern. Additionally,
				Element:a
					oauth1a spec
					and
				Element:a
					oauth bible
					can be extremely useful in understanding the 3 legged oauth flow.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					OAuth V2
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					While the official OAuth V2 spec offers lots of options, the flow we respect matches
				Element:a
					GitHub's
					and
				Element:a
					Facebook's
					implementation of the
				Element:code
					authorization_code
					flow.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
				Element:strong
					A complete OAuth V2 example is available on our
					Check that out for more detail in a real world example!
				Element:a
					Formstack example
					page.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Initial Setup
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					First, you'll need to select
				Element:code
					OAuth V2
					or
				Element:code
					OAuth V2 (w/refresh)
					as your auth type, and then provide the following parameters:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					We'll automatically create the required
				Element:code
					access_token
					and
				Element:code
					refresh_token
					(optional) auth fields for you. They look something like this in the developer interface -
				Element:strong
					the access_token field is required at minimum
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
				Element:strong
					Hint:
					Does your app need to change the URL based on the user's subdomain or domain? Simply add another authentication field (right alongside
				Element:code
					access_token
					from the above screenshot) that has the key like
				Element:code
					subdomain
					and then use it like
				Element:code
					https://{{subdomain}}.yourwebsite.com/api/token
					in all your URLs.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					1. Redirecting the User to Your App
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We'll redirect the user to an
				Element:code
					authorize_url
					(provided by you), along with a query string which contains a
				Element:code
					redirect_uri
					(provided by us),
				Element:code
					scope
					(optional, provided by you) and
				Element:code
					client_id
					(provided by you).
			Node:
			(type) c
			(layer)1
				Element:p
				Element:code
					302 <authorize_url>?client_id=<client_id>&scope=<scope>&redirect_uri=https://zapier.com/dashboard/auth/oauth/return/AppIDAPI/
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					2. Redirecting the User Back to Zapier
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					After the user clicks allow, you should redirect the user to the
				Element:code
					redirect_uri
					along with a
				Element:code
					code
					parameter in the query string.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
				Element:strong
					Note:
				Element:em
					Don't
					hardcode the
				Element:code
					redirect_uri
					on your side, as it will change as you deploy new versions of your app. If your app goes global, we'll assign you a permanent ID, but some users may be using older versions even after that point.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:code
					302 <redirect_uri>?code=<code>
			Node:
			(type) c
			(layer)1
				Element:p
					We use that
				Element:code
					code
					to make a POST to the
				Element:code
					access_token_url
					(provided by you) along with the
				Element:code
					code
					, matching
				Element:code
					redirect_uri
					(provided by us),
				Element:code
					client_id
					(provided by you), and
				Element:code
					client_secret
					(provided by you) as a form encoded request.
			Node:
			(type) c
			(layer)1
				Element:pre
					POST <access_token_url>
				Element:span
					\
					-H Accept: application/json
				Element:span
					\
					-d
				Element:span
					'client_id=<client_id>&
				Element:span
					client_secret=<client_secret>&
				Element:span
					code=<code>&
				Element:span
					grant_type=authorization_code&
				Element:span
					redirect_uri=https://zapier.com/dashboard/auth/oauth/return/AppIDAPI/'
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Zapier will try two ways to get the token: POST with data in querystring, if that returns a
				Element:code
					4xx
					, we will retry a POST with the data in the form-encoded body. You can always override this behavior with the Scripting though!
			Node:
			(type) c
			(layer)1
				Element:p
					While we ask for a JSON response, the response can be JSON, XML or query string encoded as where the value you return is
				Element:code
					access_token
					. For example, any of the below are valid responses:
			Node:
			(type) c
			(layer)1
				Element:p
					With
				Element:code
					Content-Type: application/json
					:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"access_token"
				Element:span
					:
				Element:span
					"1234567890abcdef"
				Element:span
					,
				Element:span
					"refresh_token"
				Element:span
					:
				Element:span
					"1234567890abcdef"
				Element:span
					// optional
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					With
				Element:code
					Content-Type: application/xml
					:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					<AnyRootElem>
				Element:span
					<access_token>
					1234567890abcdef
				Element:span
					</access_token>
				Element:span
					<refresh_token>
					1234567890abcdef
				Element:span
					</refresh_token>
				Element:span
					<!-- optional -->
				Element:span
					</AnyRootElem>
			Node:
			(type) c
			(layer)1
				Element:p
					With
				Element:code
					Content-Type: text/plain
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:code
					access_token=1234567890abcdef&refresh_token=1234567890abcdef
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					We automatically pull and store
				Element:code
					access_token
					and
				Element:code
					refresh_token
					from the JSON, XML, or query string data, but if you want to pull and store more fields, you can set them up in your auth setup under
				Element:em
					Extra Requested Fields
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					3. Authorizing Requests to Your App
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					By default, we append the
				Element:code
					access_token
					to the querystring for all requests, as well as in an Authorization header, however, you can use
				Element:a
					scripting
					to modify request parameters as you see fit (IE: place the
				Element:code
					access_token
					in a special header). This is called the
				Element:code
					bearer
					token type.
			Node:
			(type) c
			(layer)1
				Element:p
					An example of the default with
				Element:code
					access_token_placement
					set to
				Element:code
					header
					:
			Node:
			(type) c
			(layer)1
				Element:pre
					GET https://api.example.com/v2/tickets.json
				Element:span
					\
					-H Authorization: Bearer 1234567890abcdef
			Node:
			(type) c
			(layer)1
				Element:p
					And now with
				Element:code
					access_token_placement
					set to
				Element:code
					querystring
					:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:code
					GET https://api.example.com/v2/tickets.json?access_token=1234567890abcdef
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					4. Refreshing Tokens (optional)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Optionally, if your app supports refresh tokens, we natively support that.
			Node:
			(type) c
			(layer)1
				Element:p
					You'll need to select
				Element:code
					OAuth V2 (w/refresh)
					and provide us the
				Element:code
					refresh_token_url
					in addition to the previous requirements. When we encounter a
				Element:code
					401
					status code, we'll attempt to refresh like so:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST <refresh_token_url>
				Element:span
					\
					-H Accept: application/json
				Element:span
					\
					-d
				Element:span
					'client_id=<client_id>&
				Element:span
					client_secret=<client_secret>&
				Element:span
					grant_type=refresh_token&
				Element:span
					refresh_token=<refresh_token>'
			Node:
			(type) c
			(layer)1
				Element:p
					We will only attempt to refresh an access token when we encounter a
				Element:code
					401
					status code from your API.
			Node:
			(type) c
			(layer)1
				Element:p
					If your API does not signal expired tokens with a
				Element:code
					401
					, use
				Element:a
					scripting
					to manually set the status code header to
				Element:code
					401
					upon conditions of your choosing. Or, you can raise a
				Element:code
					RefreshTokenException
					in your
				Element:code
					post_XXXX
					function call to kick off a new refresh.
			Node:
			(type) c
			(layer)1
				Element:p
					The resulting
				Element:code
					access_token
					will be updated in our system and the previous, failed call will be attempted once more.
			Node:
			(type) c
			(layer)1
				Element:p
					We prefer and advocate one of two patterns around expiring refresh tokens:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					Never expire refresh tokens except on password changes or user revocation.
				Element:li
					In the last 10% window of a refresh token's life (IE: last 9 days of a 90 day lifetime), give a brand new refresh_token along with the normal access_token refresh.
			Node:
			(type) c
			(layer)1
				Element:p
					We fully support each pattern. While option 1 is definitely more common, option 2 works very nicely and has the effect of eventually cleaning up unused oauth tokens.
			Node:
			(type) c
			(layer)1
				Element:p
					If you cannot adhere to one of the above patterns and you app requires manual refresh of tokens on a regular basis, you should check for this condition and notify users via scripting. With
				Element:code
					throw new ExpiredAuthException('Your reason.');
					, the current call is interrupted, the zap is turned off (to prevent more calls with expired auth), and a predefined email is sent out informing the user to refresh the credentials.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Some Examples
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We highly recommend looking at each of
				Element:a
					GitHub's
					,
				Element:a
					Facebook's
					and
				Element:a
					Podio's
					(with refresh tokens) authentication documentation for some great examples of how OAuth V2 can be implemented. Our system is designed to match their industry standard implementation pattern.
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:strong
					A complete OAuth V2 example is available on our
					Check that out for more detail in a real world example!
				Element:a
					Formstack example
					page.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Polling
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Polling is the process of repeatedly hitting the same endpoint looking for new data. We don't like doing this (its wasteful), vendors don't like us doing it (again, its wasteful) and users dislike it (they have to wait a maximum interval to trigger on new data). However, it is the one method that is ubiquitous, so we support it.
			Node:
			(type) c
			(layer)1
				Element:p
					It is also closely tied into how we handle
				Element:a
					deduplication
					.
			Node:
			(type) c
			(layer)1
				Element:p
					That said, we support
				Element:a
					REST Hooks
					, so if you like to make your users and servers happy, implement hooks!
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					If you don't use classic
				Element:code
					GET
					with your API to retrieve lists of objects - you can use our
				Element:a
					scripting API to customize the polling request with a different method and body
					.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					REST Hooks
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Below is our simple standard to stop the
				Element:a
					Polling Madness
					™. This is a suggested pattern for you to implement. It was chosen because there are many examples of REST APIs providing resources around GETing, POSTing and DELETEing webhooks just like any other REST resource.
			Node:
			(type) c
			(layer)1
				Element:p
					The big benefit to REST Hooks is consumers wouldn't need to poll for changes, but could instead wait for hooks to deliver the payload. Additionally, producers can provide real-time updates with fewer devoted resources (compared to polling).
			Node:
			(type) c
			(layer)1
				Element:p
					The gist is: we POST a subscription
				Element:code
					/api/hooks
					requesting to receive hooks at some target URL. Every time the event happens, ping us at the target URL with the payload.
			Node:
			(type) c
			(layer)1
				Element:p
					After we're done, we can cleanup with a DELETE (
				Element:code
					/api/hooks/:id
					).
			Node:
			(type) c
			(layer)1
				Element:p
				Element:em
					Though we highly recommend this native pattern, you can override all the methods below with
				Element:a
					scripting
					. This means you can bend our pattern to match an existing pattern of your own.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Your Checklist
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					enumerate the events you'd like to make available as triggers
				Element:li
					create a
				Element:em
					subscribe
					REST endpoint for hooks. For example:
				Element:code
					POST /api/hooks
				Element:li
					when each event happens, loop over and notify each active subscription (or batch events of same type)
				Element:li
					respect
				Element:code
					410
					responses on payload delivery and remove subscriptions
				Element:li
					create a
				Element:em
					unsubscribe
					REST endpoint for hooks. For example:
				Element:code
					DELETE /api/hooks/:id
				Element:li
					add a polling URL for your REST Hook trigger for the best user experience
			Node:
			(type) c
			(layer)1
				Element:p
					Read on for a step by step through the endpoints involved...
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 1: Subscribe
				Element:small
				Element:em
					(a call from Zapier to your app)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					POST <subscribe_endpoint>
				Element:span
					\
					-H Authenticated: Somehow
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					'{"target_url": "https://hooks.zapier.com/<unique_target_url>",
				Element:span
					"event": "user_created"}'
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					You may notice a duplicate property
				Element:code
					subscription_url
					. That's legacy terminology. You can safely ignore it and use
				Element:code
					target_url
					only.
			Node:
			(type) c
			(layer)1
				Element:p
					This endpoint reuses whatever auth standard you have across the rest of your API (IE: Basic Auth, API Key, OAuth2, etc...). We'd send along a
				Element:strong
					unique
					,
				Element:strong
					auto-generated
					subscription URL and the event we'd like to subscribe to. These three items would be persisted on your backend (the authenticated user, target_url, and event).
			Node:
			(type) c
			(layer)1
				Element:p
					The value for the
				Element:strong
					subscribe_endpoint
					field can be specified within the "Manage Trigger Settings" option in your app's dashboard.
			Node:
			(type) c
			(layer)1
				Element:p
					The value for the
				Element:strong
					event
					field can be specified within the Trigger's setup:
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					If you prefer, you can modify this request to provide additional information (like further filtering or other metadata) via our
				Element:code
					pre_subscribe
					scripting method.
			Node:
			(type) c
			(layer)1
				Element:p
					On a successful subscribe, return a
				Element:code
					201
					status code. You should store data about the hook you just created via the
				Element:code
					post_subscribe
					scripting method (return an object like
				Element:code
					{"id": 1234}
					). You'll need this data later to unsubscribe, unless you use the subscription URL as the unique identifier, which is uncommon).
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Generally, subscription URLs should be unique. Return a
				Element:code
					409
					status code if this criteria isn't met (IE: there is a uniqueness conflict).
				Element:p
					Your service should permit a user to connect multiple webhook URLs to their account
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 2: Sending Hooks
				Element:small
				Element:em
					(a call from your app to Zapier)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://hooks.zapier.com/<unique_target_url>
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d <json payload>
			Node:
			(type) c
			(layer)1
				Element:p
					This hook could provide any amount of data or payload in either JSON or XML (or form-encoded). Just like static webhooks, we'll do our best to parse the response.
			Node:
			(type) c
			(layer)1
				Element:p
					Usually Zapier expects an array of objects. If your API only sends a single object, wrap it in a single element array:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"firstName"
				Element:span
					:
				Element:span
					"Tom"
				Element:span
					,
				Element:span
					"lastName"
				Element:span
					:
				Element:span
					"Smith"
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					On a successful hook, we'll return a
				Element:code
					200
					status code, content is irrelevant.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					If Zapier responds with a
				Element:code
					410
					status code you should immediately remove the subscription to the failing hook (unsubscribe). Additionally, excessive failures (multiple
				Element:code
					4xx
					or
				Element:code
					5xx
					failures) can be handled at your discretion. It is the clients responsibility to resubscribe if needed after failures.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Step 3: Unsubscribe
				Element:small
				Element:em
					(a call from Zapier to your app)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					DELETE <unsubscribe_endpoint>
				Element:span
					\
					-H Authenticated: Somehow
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d <content built/omitted in pre_unsubscribe scripting method>
			Node:
			(type) c
			(layer)1
				Element:p
					If you've properly stored identification data about the hook (like its unique ID) from the
				Element:code
					post_subscribe
					scripting method, you should use our
				Element:code
					pre_unsubscribe
					scripting method to formulate the DELETE call. In that call you have access to your previously stored data under the
				Element:code
					bundle.subscribe_data
					variable.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:a
					Some example code is provided to make this as easy as possible.
					A heads up: you will need to use that code if you intend to do a DELETE call. You'll be able to access
				Element:code
					bundle.subscribe_data
					to build the URL in
				Element:code
					pre_unsubscribe
					. The default behavior is slightly different and listed below.
			Node:
			(type) c
			(layer)1
				Element:p
					The value for the
				Element:strong
					unsubscribe_endpoint
					field can be specified within the "Manage Trigger Settings" option in your app's dashboard.
			Node:
			(type) c
			(layer)1
				Element:p
					However, the
				Element:strong
					current default
					does not perform a DELETE. For example, if you omit the
				Element:code
					pre_unsubscribe
					function entirely, we will attempt a default unsubscribe call:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST <unsubscribe_endpoint>
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					'{"target_url": "https://hooks.zapier.com/<unique_target_url>"}'
			Node:
			(type) c
			(layer)1
				Element:p
					On a successful unsubscribe, return a
				Element:code
					200
					status code, content is irrelevant.
			Node:
			(type) c
			(layer)1
				Element:p
					It is worth remembering that the subscription URL should effectively be unique (this could be enforced by your app as well) which also allows us to clean up unrecognized hooks (we also recommend not requiring authentication for such an endpoint).
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Optional: Reverse Unsubscribe
				Element:small
				Element:em
					(a call from your app to Zapier)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:pre
					DELETE https://hooks.zapier.com/<unique_target_url>
				Element:span
					\
					-H Content-Type: application/json
			Node:
			(type) c
			(layer)1
				Element:p
					If you'd like to allow users to manage their subscriptions from inside your app (or maybe you are cleaning up after a user deletes their account or revokes credentials) you can issue a
				Element:code
					DELETE
					to the unique target URL which was generated when the subscription was created -- this will pause the Zap on Zapier's end.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Required to Go Global: Set a polling URL
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					In the trigger setup, there is a field to define a polling URL. This URL will be used when users are setting up a Zap and must test it. Without this defined, the user must always go to your app, create a new data point, and have it send the hook to Zapier. This is not ideal, and in some cases may be particularly undesirable (if for example other Zaps are already set up on that hook, it would trigger them).
			Node:
			(type) c
			(layer)1
				Element:p
					Setting up a polling URL fixes this. The polling URL is only used during this testing phase, not during the regular operation of the Zap. If you need to script special behavior, you can do so using the standard
				Element:code
					pre_poll
					and
				Element:code
					post_poll
					methods on the trigger key.
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:strong
					Note
					: Please ensure that the data format that returns from the Polling URL is the same as what returns from the REST Hook, so users can correctly map fields.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Request Log
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We log the requests your app makes to aid in debugging. We collect every request, successful or not, during the development stage. As soon as your app is approved, we only log requests that have status codes of >= 300.
			Node:
			(type) c
			(layer)1
				Element:p
					The logged request list on your app dashboard should look like:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Clicking details will give you lots more information, like headers, query strings, POST and response data.
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:strong
					Note:
					we also offer rudimentary JavaScript exceptions messages via
				Element:a
					scripting
					. We plan on offering more details along with tracebacks soon.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Scripting
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					See our full
					↑ Was this documentation useful?
				Element:a
					Scripting
					document for more details.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Searches
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Overview
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					Searches
					answer the question:
				Element:em
					What records can I lookup by a particular query?
					They are things like:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Find a Contact
				Element:li
					Find a Product
				Element:li
					Find an Issue
			Node:
			(type) c
			(layer)1
				Element:p
					Searches can be useful on their own, or they can be combined with Actions to perform "Get or Create" style logic.
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					See also:
				Element:a
					Searches in the CLI
			Node:
			(type) c
			(layer)1
				Element:p
					You can define your searches via your app's dashboard. When you create a new search, you'll be prompted with several options. Below we list all complete definitions of what each option is for.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Search Options
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Name
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is a human readable label a user would see when browsing the directory and adding your app. Make it short but descriptive.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Find a Contact
					or
				Element:code
					Find Ticket
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Noun
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is the object that the search is most closely associated with. It will be a noun you used in the Name field. We rely on an accurate noun to generate human-friendly sentences for users.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
					"Find Contact" would have "Contact" as the noun. "Find Completed Sale" would use "Sale" or "Completed Sale".
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is a field only really used internally for both
				Element:a
					dynamic dropdown
					and
				Element:a
					Scripting
					references. Needs to be at least two characters long, start with an alpha, and only contain
				Element:code
					a-z
					,
				Element:code
					A-Z
					,
				Element:code
					0-9
					or
				Element:code
					_
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					find_contact
					, or
				Element:code
					findContact
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Help Text
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A longer description of what this Search actually looks for. Point out any un-standard behavior as far as how searching happens.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Finds a contact by email address.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Important
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Usually you'll want to leave this checked, but if you don't we'll hide that search behind an "uncommon" link when a user selects their action. Mainly this is helpful for removing searches that are there for breadth but are rarely used.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Hide
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Usually you'll want to leave this unchecked. If you check it, we'll completely hide the search from the enduser. This can be useful if a search is incomplete, but you need to deploy your app in it's current state. This option is also a way to hide searches that become deprecated in your API.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Search Endpoint
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Define the URL route where we will, by default,
				Element:code
					GET
					for a list of results. Note that the results
				Element:em
					must
					be an array, otherwise your search may fail. If your API returns a single object, you can use scripting to wrap the object in an array in a
				Element:code
					_post_search
					method. You can also make use of
				Element:a
					variable syntax
					where
				Element:a
					auth fields
					and
				Element:a
					search fields
					will be injected.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					http://api.example.com/v2/clients.json
					or
				Element:code
					http://{{account}}.example.com/api/v1/projects.json
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Note we'll only use the first object in the array for now, so if you can add optional fields to help narrow the search down, it's a great idea.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h4
					A Warning about encoding URL params
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We will not automatically encode any URL variables, so you're responsible for encoding any if they require that. For example, emails
				Element:em
					might
					include a
				Element:code
					+
					sign, so if you have
				Element:code
					https://example.com/api/v2/leads?email={{email}}
					you'll want to encode that in your
				Element:a
					(or remove it from there and add it to the
				Element:code
					SEARCH_KEY_pre_search
				Element:code
					bundle.request.params
					), otherwise you'll get a "space" where the
				Element:code
					+
					sign is.
			Node:
			(type) c
			(layer)1
				Element:p
					A better approach is to not even include it in the URL and to instead
				Element:em
					only
					use
				Element:code
					bundle.request.params
					in this case since
				Element:code
					bundle.request.params
					will be encoded automatically.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Custom Search Fields URL
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This allows you to dynamically define search fields that are user set (IE: custom fields).
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					http://api.example.com/v2/fields.json
					or
				Element:code
					http://{{account}}.example.com/api/v1/fields.json
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Read more about
				Element:a
					custom field formating here
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Resource URL
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The URL we can use to fetch a single record. This will be used to perform a follow-up GET on results we get back from the Search Endpoint (and in the case of a Search-or-Create Zap, the create step as well).
			Node:
			(type) c
			(layer)1
				Element:p
					You can make use of
				Element:a
					variable syntax
					where
				Element:a
					auth fields
					and search result fields (not the actual
				Element:a
					search fields
					) will be injected.
			Node:
			(type) c
			(layer)1
				Element:p
					You will want to provide this in case your Search (or Create) Endpoint don't return all useful information about a record that you might get by fetching it directly.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					https://api.example.com/v2/leads/{{id}}.json
					or
				Element:code
					https://{{account}}.example.com/api/v1/leads/{{id}}.json
			Node:
			(type) c
			(layer)1
				Element:p
					Assuming your search would return something like:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					124
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					And you had an
					↑ Was this documentation useful?
				Element:code
					account
					Authentication variable, for example.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Search Fields
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Overview
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Search Fields answer the question: what details can a user provide when setting up a Search?
			Node:
			(type) c
			(layer)1
				Element:p
					These details might include:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Name to query for a Contact
				Element:em
					(EG: Salesforce)
				Element:li
					Repo to restrict search to for an Issue
				Element:em
					(EG: Github)
				Element:li
					Notebook for a Note
				Element:em
					(EG: Evernote)
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Each Search should have at least one Search Field, because otherwise we won't know what to include in the query.
			Node:
			(type) c
			(layer)1
				Element:p
					You can also dynamically load custom Search Fields by inspecting a custom field endpoint of your own.
				Element:a
					Learn more.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Search Field Options
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A key for you and your API's consumption. This is available for
				Element:a
					variable syntax
					in the Search URL field as well as in
				Element:a
					Scripting
					. Needs to be at least two characters long, start with an alpha, and only contain
				Element:code
					a-z
					,
				Element:code
					A-Z
					,
				Element:code
					0-9
					or
				Element:code
					_
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					room
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Label
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A human readable Label shown in the UI as a user works to complete a Search.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Email
					or
				Element:code
					Name
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Help Text
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Human readable description of a Search field, useful for describing some detail you couldn't list in the Label.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Specify the first name to search by.
					or
				Element:code
					Restrict the search to contacts in this category.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Default
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A default value for a field. The behavior varies between required and optional fields. For required fields, the default will be set once when the user first creates the Search, but it is not guaranteed after that (we raise an error on missing/null values instead). For optional fields, it is set on initial creation and used in place of missing or null values every time the Zap runs.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Type
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The type we will try to coerce to on the backend. Fails silently to ensure that tasks aren't dropped on coercion errors.
			Node:
			(type) c
			(layer)1
				Element:p
					You can get a full list of supported types and the coercion implied here:
				Element:a
					Field Types
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Required
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If checked a user will not be able to continue without entering some value.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Dynamic Dropdown
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Use an existing
				Element:a
					Trigger
					to load in values for selection, using the machine readable value your API consumes (like
				Element:code
					id
					or
				Element:code
					hash
					) while showing a human readable version to the user (like
				Element:code
					name
					or
				Element:code
					itemName
					).
			Node:
			(type) c
			(layer)1
				Element:p
					Refer to our
				Element:a
					dynamic dropdown docs
					for a more in depth explanation.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					TRIGGERKEY.id.name
					or
				Element:code
					TRIGGERKEY.hash.itemName
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Static Dropdowns
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A comma separated string that will be turned into a select field for limiting the choices a user can provide to a Search field.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					choice_a,choice_b,choice_c
					or
				Element:code
					Yesterday, Today, Tomorrow
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					If you would like to provide a label for the raw value of each choice, you can also use the raw|label,raw|label syntax instead.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					1|Option 1,2|Option 2
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					List
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Indicates if this field can hold multiple values. For example, this could be useful if you want to allow users to search for a contact by name, but limit the search to contacts with one or more tags applied. List fields gain the +/- icons to the side.
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:img
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Search or Create
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Search or Create allows users to combine your Searches and your Actions together into one flow. Each Search may be associated with one Action, which represents the creation of the same type of object that search is used to look up. (Practical example
				Element:a
					here
					)
			Node:
			(type) c
			(layer)1
				Element:p
					Example use cases might include:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Find or create a new customer
				Element:em
					(EG: Salesforce)
				Element:li
					Notebook for a Note
				Element:em
					(EG: Evernote)
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					The user's UI is built using a combination of the
				Element:code
					label
					above and the related
				Element:code
					label
					and
				Element:code
					noun
					from the single Search and Action.
			Node:
			(type) c
			(layer)1
				Element:p
					At this point, when the user selects the checkbox to do a Find or Create, they will be given the option to fill in both the fields for the search, as well as the fields for the create.
			Node:
			(type) c
			(layer)1
				Element:p
					When the Zap runs, if an element is found during the Search, it will be used. If not, a new item will be created.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Errors like a 404 will not be interpreted as a "miss" on search and will not trigger a follow up create - explicitly return
				Element:code
					[]
					when no records are found. If your API can't do that, use scripting to return an empty list
				Element:code
					[]
					(note a
				Element:code
					_post_search
					won't work, you'll have to replace
				Element:code
					_search
					completely)
			Node:
			(type) c
			(layer)1
				Element:p
					This type of connection should be used in cases where the search is likely to yield one correct result, and unlikely to yield incorrect results. Good use cases include searching by keys like
				Element:code
					email
					or
				Element:code
					phone number
					, or other uniquely identifying information that the user might have.
			Node:
			(type) c
			(layer)1
				Element:p
					After every successful Search or Create - we'll attempt to grab a fresh record via the
					↑ Was this documentation useful?
				Element:a
					Resource URL
					.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Search Fields (Custom)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A natural extension of normal hard coded
				Element:a
					search fields
					are dynamic search fields, or custom fields. All you need to do to enable custom fields is:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Provide a
				Element:code
					Custom Search Fields URL Route
					for the Search in question.
				Element:li
					Ensure the URL route returns data in the below format, or manipulate to fit with
				Element:a
					Scripting
					.
				Element:li
					You can choose from several internal types, documented here:
				Element:a
					Field Types
					.
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"type"
				Element:span
					:
				Element:span
					"unicode"
				Element:span
					,
				Element:span
					"key"
				Element:span
					:
				Element:span
					"json_key"
				Element:span
					,
				Element:span
					"required"
				Element:span
					:
				Element:span
					false
				Element:span
					,
				Element:span
					// whether this field must be filled out. defaults to true
				Element:span
					"label"
				Element:span
					:
				Element:span
					"Pretty Label"
				Element:span
					,
				Element:span
					// optional
				Element:span
					"help_text"
				Element:span
					:
				Element:span
					"Helps to explain things to users."
				Element:span
					,
				Element:span
					// optional
				Element:span
					"choices"
				Element:span
					:
				Element:span
					{
				Element:span
					// optional
				Element:span
					"raw"
				Element:span
					:
				Element:span
					"label"
				Element:span
					}
				Element:span
					// can also be a flat array if raw is the label
				Element:span
					},
				Element:span
					...
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					Right now
				Element:code
					parent_key
					and
				Element:code
					type=dict
					is not supported in custom fields.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Search Sample Results
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					(This works similar to
				Element:a
					trigger sample results
					)
			Node:
			(type) c
			(layer)1
				Element:p
					To help give users a smooth experience when creating multi-step Zaps, we ask that you paste a JSON object that contains the fields (along with sample values), so that your user can map those fields into the next step.
			Node:
			(type) c
			(layer)1
				Element:p
					We will use this sample JSON for two things:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					To detect a list of hard-coded key names which the user can pick from during Zap setup
				Element:li
					To use as a hard-coded fallback for sample data so that we can provide fields to insert during Zap setup (if your API returns 0 results)
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					These result is primarily used when the user picks "Skip Test" when testing their Zap. Zapier will try to use a live API result, first.
			Node:
			(type) c
			(layer)1
				Element:p
					Here is the sample JSON for something like an search for a Trello Card, and how it shows up in our user-facing Editor:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"name"
				Element:span
					:
				Element:span
					"Some Card"
				Element:span
					,
				Element:span
					"url"
				Element:span
					:
				Element:span
					"https://trello.com/c/YZSaTvjM/59-some-card"
				Element:span
					,
				Element:span
					"id"
				Element:span
					:
				Element:span
					"5642335fa1041c95e73f290b"
				Element:span
					,
				Element:span
					"idList"
				Element:span
					:
				Element:span
					"55159df870b769081c4a8e82"
				Element:span
					,
				Element:span
					"pos"
				Element:span
					:
				Element:span
					65535
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					We will parse this sample and provide dropdowns like this to the user:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					By default, we can handle flat dictionaries and dictionaries within dictionaries (via our
				Element:code
					__
					delimiter in keys).
			Node:
			(type) c
			(layer)1
				Element:p
					When the user is inserting fields in the Zap editor, and your API returns no results (
				Element:code
					[]
					) then we will use your hard-coded fallback JSON if it exists.
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					Your hard-coded JSON provided above will
				Element:em
					not
					be run through the Scripting API (either for key enumeration or sample data fallback) so if you use the Scripting API to add or modify fields on top of your normal API response, you'll want to make sure you perform the same manipulations manually before pasting in the JSON above.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Static Webhooks
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Static webhooks are a very simple version of webhooks wherein the user of your service will have to take action to enable a webhook. Usually, this is done copying a url that Zapier provides during the Zap setup process (like
				Element:code
					https://zapier.com/hooks/catch/123/n/456789/
					). We would prefer you use
				Element:a
					REST hooks
					but that usually requires extra code and a full REST API.
			Node:
			(type) c
			(layer)1
				Element:p
					While Static webhooks are very useful for rapid prototyping, we don't generally accept apps for inclusion in the Zapbook that are solely Static webhooks. Users can use our built in Webhook app to do the same things that a purely Static webhook app can do. You should look at
				Element:a
					REST Hooks
					as the next step after you've proved the concept privately with Static webhooks.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:em
					To get a taste of how static webhooks work, check out our built-in
				Element:a
					generic webhook service
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Setup the Webhooks
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					To get started simply create a new trigger on your app, choosing static webhook as the type. You can follow the
				Element:a
					Hubspot example
					to see a detailed walk through of how to do this.
			Node:
			(type) c
			(layer)1
				Element:p
					Once defined in your app, static webhook triggers will appear like this to users when they create a Zap:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Using the Webhooks
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					For as long as the Zap exists, requests made to that URL will be associated with your app and the user. That means requests made during the setup process (while the Zap is paused) will still get stored, making it easier for users to debug. However, requests will
				Element:strong
					not
					trigger any actions until the Zap is turned on.
			Node:
			(type) c
			(layer)1
				Element:p
					Also, it is important to know that by default, we do our best to inspect and pull out all relevant information in a request. If you use
				Element:a
					scripting
					to further refine the hook data, you'll see it passed in as
				Element:code
					bundle.cleaned_request
					. For example, a request might have a
				Element:code
					cleaned_request
					similar to:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://zapier.com//hooks/catch/123/n/456789/?hello
				Element:span
					=
					world
				Element:span
					\
					-H Content-Type: application/x-www-form-urlencoded
				Element:span
					\
					-d
				Element:span
					'some_json=%7B%22foo%22%3A%22hooray!%22%7D&some_xml=%3Cbar%3Eyay!%3C%2Fbar%3E'
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"queryset"
				Element:span
					:
				Element:span
					{
				Element:span
					"hello"
				Element:span
					:
				Element:span
					"world"
				Element:span
					,
				Element:span
					},
				Element:span
					"some_json"
				Element:span
					:
				Element:span
					{
				Element:span
					"foo"
				Element:span
					:
				Element:span
					"hooray!"
				Element:span
					},
				Element:span
					"some_xml"
				Element:span
					:
				Element:span
					{
				Element:span
					"bar"
				Element:span
					:
				Element:span
					"yay!"
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					Of course, more simplistic examples like straight JSON or XML are handled as you'd expect.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Catching Single Objects vs. Lists
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Some webhooks send single objects, while some are batched as lists of objects for efficiency reasons. Though Zapier supports both, we highly recommend using
				Element:a
					scripting
					if you are dealing with batched lists. We do our best via
				Element:code
					cleaned_request
					to interpret lists where possible, but if your list is hidden in a subkey, we won't capture it properly.
			Node:
			(type) c
			(layer)1
				Element:p
					For example, a generically supported list:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://zapier.com//hooks/catch/123/n/456789/?hello
				Element:span
					=
					world
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					'[{"name":"bryan","age":27},{"name":"mike","age":23}]'
			Node:
			(type) c
			(layer)1
				Element:p
					Would result in two triggers...
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"name"
				Element:span
					:
				Element:span
					"bryan"
				Element:span
					,
				Element:span
					"age"
				Element:span
					:
				Element:span
					27
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					...and...
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"name"
				Element:span
					:
				Element:span
					"mike"
				Element:span
					,
				Element:span
					"age"
				Element:span
					:
				Element:span
					23
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					Notice that the query string
				Element:code
					hello=world
					is ignored? That is because we assumed the data list was more important and we didn't want to maim the data contained therein.
			Node:
			(type) c
			(layer)1
				Element:p
					Check out an example where we would ignore a subkeyed list:
			Node:
			(type) c
			(layer)1
				Element:pre
					POST https://zapier.com//hooks/catch/123/n/456789/?hello
				Element:span
					=
					world
				Element:span
					\
					-H Content-Type: application/json
				Element:span
					\
					-d
				Element:span
					'{"data":[{"name":"bryan","age":27},{"name":"mike","age":23}]}'
			Node:
			(type) c
			(layer)1
				Element:p
					Because the list isn't at the root, by default, we'll interpret this as a single object. That means we'll only trigger once for this object:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"queryset"
				Element:span
					:
				Element:span
					{
				Element:span
					"hello"
				Element:span
					:
				Element:span
					"world"
				Element:span
					,
				Element:span
					},
				Element:span
					"some_json"
				Element:span
					:
				Element:span
					[
				Element:span
					{
				Element:span
					"name"
				Element:span
					:
				Element:span
					"bryan"
				Element:span
					,
				Element:span
					"age"
				Element:span
					:
				Element:span
					27
				Element:span
					},
				Element:span
					{
				Element:span
					"name"
				Element:span
					:
				Element:span
					"mike"
				Element:span
					,
				Element:span
					"age"
				Element:span
					:
				Element:span
					23
				Element:span
					}
				Element:span
					]
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					This is where you'd need to break out
				Element:a
					scripting
					to do some refinement. Check out the examples we provide in the
				Element:a
					scripting examples
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Testing Webhooks
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Normally, a user will just log back into your service and force an event by performing the action that causes a webhook to be emitted. This can be a little annoying to the user during setup, so alternatively you can send a
					↑ Was this documentation useful?
				Element:code
					X-Hook-Test: true
					and we will
				Element:em
					never
					trigger an action for real, we'll just cache the payload for our UI. This means when the user enables webhooks in your app, just send some sample data across.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Style Guide
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					See our full
					↑ Was this documentation useful?
				Element:a
					Style Guide
					document.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Test Triggers
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A test trigger is a regular
				Element:a
					trigger
					with a special responsibility. The test trigger is the trigger Zapier will use to verify the authentication credentials users provide when they first attempt to access your API through Zapier. If your API returns a
				Element:code
					2XX
					status code, we will assume the credentials are valid. Anything else (or an empty response that isn't a
				Element:code
					204
					), and we will assume the credentials are bad.
			Node:
			(type) c
			(layer)1
				Element:p
					You can only mark one trigger as the test trigger. A test trigger can be made for any endpoint in your API that:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					Requires authentication
				Element:li
					Is guaranteed to always return some data (or a 204 for empty responses)
			Node:
			(type) c
			(layer)1
				Element:p
					Some examples of good endpoints to use for the test trigger:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					A url like
				Element:code
					/ping
					that is meant solely to test authentication
				Element:li
					An endpoint that returns a user's profile
				Element:li
					An endpoint for high-level objects in your API that users are virtually guaranteed to have (i.e. contacts if you are a CRM, tickets if you are a support center)
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Setting one up
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					In your app, you'll need choose a trigger that performs a "simple test" when its Polling URL is used to access an endpoint that requires valid authorization/credentials.
			Node:
			(type) c
			(layer)1
				Element:p
					If your trigger is intended to be solely used for authentication testing, then you can mark it hidden.
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					Important
					make sure that the test trigger doesn't have any "Required" trigger fields (because they'll be empty when we perform the auth test)
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Errors
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					When your test trigger fails, a message will be displayed to the user "App returned (400) Error and said nothing" or something similar. This is constructed from the response status code and status message returned from your endpoint, along with a message from the response body, like so:
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					App return (
				Element:code
					response.status_code
					)
				Element:code
					response.status_message
					and said
				Element:code
					response.body
			Node:
			(type) c
			(layer)1
				Element:p
					The message is interpreted from the response.body as such:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					We check to see if you send back JSON. If so, we look for a message field, or similar in the JSON object.
				Element:li
					We check to see if you send back an XML file (i.e., xml in the Content-Type header). If so, we do a similar lookup for an error message in the body.
				Element:li
					We then check to see if you sent back a plain text response(i.e., Content-Type: text/plain). If so, we check that the content is < than 180 characters and use it verbatim.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Testing
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					To select your test trigger, use the button "Manage Trigger Settings":
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Scroll down to the bottom of the page, and select the appropriate trigger:
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:img
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Triggers
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Overview
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					Triggers
					answer the question:
				Element:em
					What events can my users listen for with Zapier?
					They are things like:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					New Contact
				Element:em
					(EG: Highrise or Salesforce)
				Element:li
					New Email
				Element:em
					(EG: Gmail or IMAP)
				Element:li
					New Issue
				Element:em
					(EG: GitHub or Pivotal Tracker)
			Node:
			(type) c
			(layer)1
				Element:p
					You can think of a Trigger as a GET or read. It involves Zapier receiving data from your app.
			Node:
			(type) c
			(layer)1
				Element:p
					For example, say your app has a "New Ticket Opened" trigger. We will watch for new tickets in a user's account. The data we trigger off of might look like this:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					123456
				Element:span
					,
				Element:span
					"owner_id"
				Element:span
					:
				Element:span
					654
				Element:span
					,
				Element:span
					"date_created"
				Element:span
					:
				Element:span
					"Mon, 25 Jun 2012 16:41:54 -0400"
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"Add our app to Zapier"
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
				Element:em
					Note: The data in the response must be an array, even for a single data point.
			Node:
			(type) c
			(layer)1
				Element:p
					These key/values are available for users to map into the
				Element:a
					action
					as they see fit.
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					See also:
				Element:a
					Triggers in the CLI
			Node:
			(type) c
			(layer)1
				Element:p
					You can define your triggers via your app's dashboard. When you create a new trigger, you'll be prompted with several options. Below we list all complete definitions of what each option is for.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Trigger Options
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Name
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is a human readable label a user would see when browsing the directory and adding your app. Make it short but descriptive.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					New Ticket Created
					or
				Element:code
					New Email with Label
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Noun
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is the object that the trigger is most closely associated with. It will be a noun you used in the Name field. We rely on an accurate noun to generate human-friendly sentences for users.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
					"New Ticket Created" would have "Ticket" as the noun. "New Email with Label" would use "Email" or "Labeled Email".
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This is a field only really used internally for both
				Element:a
					dynamic dropdown
					and
				Element:a
					scripting
					references. Needs to be at least two characters long, start with an alpha, and only contain
				Element:code
					a-z
					,
				Element:code
					A-Z
					,
				Element:code
					0-9
					or
				Element:code
					_
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					new_ticket
					, or
				Element:code
					newEmailLabel
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Help Text
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A longer description of what this trigger actually watches for.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Triggers when a new email occurs with a label of your choice.
			Node:
			(type) c
			(layer)1
				Element:p
					Demo:
				Element:br
				Element:em
					the user will see
				Element:strong
					Name
					and
				Element:strong
					Help Text
					like below:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Important
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Occasionally, you'll have unimportant triggers which are used mostly to drive things like
				Element:a
					dynamic dropdown
					, but could be useful to a small subset of users. If you mark a trigger as unimportant, we will hide the trigger behind a link. The user can still pick these if they really want to but it is hidden by default.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Note: if you have no important triggers, we will not hide any of them by default.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Hide
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If you create a trigger solely to be used in a
				Element:a
					dynamic dropdown
					and it will never be helpful to users, you can mark it as hidden. We will never show the trigger in the UI and users will not be able to pick it.
			Node:
			(type) c
			(layer)1
				Element:p
					This usually comes up with
				Element:a
					test triggers
					, where the test trigger is for an endpoint that always returns the same data (a user profile, for instance).
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Paging
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					When defining a trigger to power a
				Element:a
					dynamic dropdown
					you can use the
				Element:a
					Scripting API
					to implement paging by relying on
				Element:code
					bundle.meta.page
					.
			Node:
			(type) c
			(layer)1
				Element:p
					This flag must be set in order to enable paging in the dynamic dropdowns powered by this trigger. If set, the user will see the option in the dropdown to load more choices: “Don’t see your choices? Try loading more than {x}.”
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					Otherwise, the user will see standard language: “Check {your app} and reload the data”
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Note: Paging is
				Element:strong
					not used
					in normal trigger polling calls.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Polling: URL
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Where in your API can
				Element:a
					we poll
					for this trigger? Your URL route can include
				Element:a
					variables
					(from
				Element:a
					authentication fields
					and
				Element:a
					trigger fields
					), as well as query parameters. Query parameters are helpful for telling your API to sort things in reverse-chronological order,
				Element:a
					a requirement we have
					.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Important: this endpoint should return a
				Element:em
					list
					of JSON objects.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					https://example.com/api/v1/users/{{id}}/contacts.json?sort=desc&on=date_created
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h4
					A Warning about encoding URL params
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					We will not automatically encode any URL variables, so you're responsible for encoding any if they require that. For example, emails
				Element:em
					might
					include a
				Element:code
					+
					sign, so if you have
				Element:code
					https://example.com/api/v1/users?email={{email}}
					you'll want to encode that in your
				Element:a
					(or remove it from there and add it to the
				Element:code
					TRIGGER_KEY_pre_poll
				Element:code
					bundle.request.params
					), otherwise you'll get a "space" where the
				Element:code
					+
					sign is.
			Node:
			(type) c
			(layer)1
				Element:p
					A better approach is to not even include it in the URL (it'll be added and encoded automatically in that case).
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Custom Trigger Fields URL
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					This allows you to dynamically define user-friendly labels for data returned by triggers. These labels are shown to users in the Zap editor when setting up Actions.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					http://api.example.com/v2/fields.json
					or
				Element:code
					http://{{account}}.example.com/api/v1/fields.json
			Node:
			(type) c
			(layer)1
				Element:p
					If your polling trigger returns:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					1
				Element:span
					,
				Element:span
					"q_1"
				Element:span
					:
				Element:span
					"Yes"
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					You can return in the custom fields URL something like:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					[
				Element:span
					{
				Element:span
					"label"
				Element:span
					:
				Element:span
					"Are you happy with your service?"
				Element:span
					,
				Element:span
					"key"
				Element:span
					:
				Element:span
					"q_1"
				Element:span
					,
				Element:span
					"important"
				Element:span
					:
				Element:span
					true
				Element:span
					,
				Element:span
					"type"
				Element:span
					:
				Element:span
					"unicode"
				Element:span
					}
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:p
					And the UI will be more easy to understand.
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Read more about
				Element:a
					custom field formatting here
					.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Webhook: Event Name
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A part of our
				Element:a
					REST Hooks
					, this lets you namespace the name of event that this trigger identifies with.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Webhook: Static Webhook
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A part of our
				Element:a
					static webhooks
					, this simply toggles the ability to receive webhooks and disables polling.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Webhook: Static Webhook Directions
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A part of our
					↑ Was this documentation useful?
				Element:a
					static webhooks
					, when static webhooks are in use this lets you define specialized directions for setup. It also supports
				Element:a
					Markdown
					so you can provide links or other specialized HTML formatting.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Trigger Fields
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Overview
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
				Element:strong
					Trigger Fields
					answer the question:
				Element:em
					How can a user filter Triggers?
					Almost exclusively these are
				Element:a
					dynamic dropdowns
					, but some real world examples are:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Search Term
				Element:em
					(EG: Twitter Tweet Search)
				Element:li
					Label
				Element:em
					(EG: Gmail Inbox)
				Element:li
					Parent Object
				Element:em
					(span relationships via
				Element:a
					dynamic dropdowns
					)
				Element:li
					Repo for an Issue
				Element:em
					(EG: Github)
				Element:li
					Notebook for a Note
				Element:em
					(EG: Evernote)
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					Imagine an endpoint like
				Element:code
					https://example.com/api/v1/prospects.json
					- that would require no trigger fields at all. However an endpoint like
				Element:code
					https://example.com/api/v1/list/1234/prospects.json
					- that would require at least a trigger field to select the list ID (and it would be a
				Element:a
					dynamic dropdown
					at that!).
			Node:
			(type) c
			(layer)1
				Element:p
					What a user sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					What a developer sees:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					When you attempt to add a trigger field, you'll be prompted to provide some options which are outlined below.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Trigger Field Options
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Key
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A key for your internal use. It is available for
				Element:a
					variable syntax
					in the Trigger URL field (as well as in
				Element:a
					scripting
					). Needs to be at least two characters long, start with an alpha, and only contain
				Element:code
					a-z
					,
				Element:code
					A-Z
					,
				Element:code
					0-9
					or
				Element:code
					_
					.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					project
					or
				Element:code
					search_term
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Label
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A human readable Label shown in the UI as a user builds a Zap.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Room
					or
				Element:code
					Title
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Help Text
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Human readable description of a trigger field, useful for describing some detail you couldn't list in the Label.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					Choose which project to watch for new messages.
					or
				Element:code
					Define a search term for finding Tweets.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Default
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A default value for a field. The behavior varies between required and optional fields. For required fields, the default will be set once when the user first creates the Trigger, but it is not guaranteed after that (we raise an error on missing/null values instead). For optional fields, it is set on initial creation and used in place of missing or null values every time the Zap runs.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Type
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The type we will try to coerce to. Falls back to unicode (text) if coercion fails.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Required
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If checked a user will not be able to continue without entering some value.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Dynamic Dropdown
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Use an existing
				Element:a
					Trigger
					to load in values for selection, using the machine readable value your API consumes (like
				Element:code
					id
					or
				Element:code
					hash
					) while showing a human readable version to the user (like
				Element:code
					name
					or
				Element:code
					itemName
					).
			Node:
			(type) c
			(layer)1
				Element:p
					In our experience, most trigger fields are dynamic dropdowns.
			Node:
			(type) c
			(layer)1
				Element:p
					Refer to our
				Element:a
					dynamic dropdown docs
					for a more in depth explanation.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					TRIGGERKEY.id.name
					or
				Element:code
					TRIGGERKEY.hash.itemName
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					Static Dropdown
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					A comma separated string that will be turned into a select field for limiting the choices a user can provide to a trigger field.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					choice_a,choice_b,choice_c
					or
				Element:code
					Yesterday, Today, Tomorrow
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					If you would like to provide a label for the raw value of each choice, you can also use the raw|label,raw|label syntax instead.
			Node:
			(type) c
			(layer)1
				Element:p
					Example:
				Element:br
				Element:code
					1|Option 1,2|Option 2
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h3
					List
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Indicates if this field can hold multiple values. For example, this could be useful if you want to allow users to only trigger on new contacts with one or more tags applied. List fields gain the +/- icons to the side.
			Node:
			(type) c
			(layer)1
				Element:p
					↑ Was this documentation useful?
				Element:img
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Trigger Fields (Custom)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Sometimes, the data returned by a trigger is hard to use in a Zap because of how the keys are named. When a user goes to map fields in an action, the trigger data's keys are used to identify which field is which. If those keys are something unintelligible like UUIDs rather than human-readable data points like
				Element:code
					"name"
					or
				Element:code
					"email"
					, the user may not be able to identify which fields to map in their action.
			Node:
			(type) c
			(layer)1
				Element:p
					To remedy this, we have Custom Trigger Fields, an additional HTTP GET to a URL you provide in your trigger definition that tells us additional metadata about the data the trigger will return, such as human-readable labels to display when mapping fields. All you need to do to enable custom trigger fields is:
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Provide a
				Element:code
					Custom Trigger Fields URL Route
					for the trigger in question.
				Element:li
					Ensure the URL route returns data in the below format, or manipulate to fit with
				Element:a
					a
					.
				Element:code
					_post_custom_trigger_fields
					scripting method
			Node:
			(type) c
			(layer)1
				Element:pre
					↑ Was this documentation useful?
				Element:span
					[
				Element:span
					{
				Element:span
					"type"
				Element:span
					:
				Element:span
					"unicode"
				Element:span
					,
				Element:span
					// unicode, int, or bool
				Element:span
					"key"
				Element:span
					:
				Element:span
					"json_key"
				Element:span
					,
				Element:span
					// the key in the trigger data
				Element:span
					"label"
				Element:span
					:
				Element:span
					"Pretty Label"
				Element:span
					,
				Element:span
					// the human-readable label to display
				Element:span
					},
				Element:span
					...
				Element:span
					]
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Trigger Sample Results
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					To help give users a clean experience when creating Zaps, we ask that you paste a sample JSON dictionary of a single item from your API into Zapier.
			Node:
			(type) c
			(layer)1
				Element:p
					We will use this sample JSON for two things:
			Node:
			(type) c
			(layer)1
				Element:ol
				Element:li
					To detect a list of hard-coded key names which the user can pick from during Zap setup
				Element:li
					To use as a hard-coded fallback for sample data so that we can provide fields to insert during Zap setup (if your API returns 0 results)
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					These results will NOT be used for a user's Zap testing step. That step requires data to be received by an event or returned from a polling URL.
			Node:
			(type) c
			(layer)1
				Element:p
					Here is the sample JSON for something like a new email message, and how it shows up in our user-facing Editor:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"to_name"
				Element:span
					:
				Element:span
					"Mike Knoop"
				Element:span
					,
				Element:span
					"to_address"
				Element:span
					:
				Element:span
					"mike@zapier.com"
				Element:span
					,
				Element:span
					"from_name"
				Element:span
					:
				Element:span
					"Bryan Helmig"
				Element:span
					,
				Element:span
					"from_address"
				Element:span
					:
				Element:span
					"bryan@zapier.com"
				Element:span
					,
				Element:span
					"subject"
				Element:span
					:
				Element:span
					"Testing out this new Zap!"
				Element:span
					,
				Element:span
					"message"
				Element:span
					:
				Element:span
					{
				Element:span
					"no_html"
				Element:span
					:
				Element:span
					"Let me know it it works."
				Element:span
					,
				Element:span
					"html"
				Element:span
					:
				Element:span
					"<div>Let me know if it works.</div>"
				Element:span
					}
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
				Element:em
					Note: Even though your API endpoint has to return an array, the sample JSON here must be of a single object.
			Node:
			(type) c
			(layer)1
				Element:p
					We will parse this sample and provide dropdowns like this to the user:
			Node:
			(type) c
			(layer)1
				Element:p
				Element:img
			Node:
			(type) c
			(layer)1
				Element:p
					By default, we can handle flat dictionaries and dictionaries within dictionaries (via our
				Element:code
					__
					delimiter in keys).
			Node:
			(type) c
			(layer)1
				Element:p
					When the user is inserting fields in the Zap editor, and your API returns no results (
				Element:code
					[]
					) then we will use your hard-coded fallback JSON if it exists.
			Node:
			(type) c
			(layer)1
				Element:blockquote
					↑ Was this documentation useful?
				Element:p
					Your hard-coded JSON provided above will
				Element:em
					not
					be run through the Scripting API (either for key enumeration or sample data fallback) so if you use the Scripting API to add or modify fields on top of your normal API response, you'll want to make sure you perform the same manipulations manually before pasting in the JSON above.
				Element:p
					Note - our system often does a sample "poll" or pulls cached values for a live example - samples are just a part of that system. If you need to omit bad fields from usage - you'll need to ensure the poll or webhook or whatever does not included the bad fields either!
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Variable Syntax
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					If you've used
				Element:a
					Django
					or
				Element:a
					Mustache
					(or many other templating engines), you are probably well versed in the variable syntax we use. This also happens to be the exact same syntax our users use to map data from triggers into
				Element:a
					Action Fields
					(though they get a dropdown interface to do it).
			Node:
			(type) c
			(layer)1
				Element:p
					Given the following context (think
				Element:a
					authentication fields
					or data from triggers):
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"id"
				Element:span
					:
				Element:span
					123456
				Element:span
					,
				Element:span
					"owner"
				Element:span
					:
				Element:span
					"Larry"
				Element:span
					,
				Element:span
					"title"
				Element:span
					:
				Element:span
					"Hello world!"
				Element:span
					,
				Element:span
					"description"
				Element:span
					:
				Element:span
					"It's a beautiful day!"
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					And the following template (think
				Element:a
					authentication mapping
					or
				Element:a
					action fields
					):
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"talking_user"
				Element:span
					:
				Element:span
					"{{owner}}"
				Element:span
					,
				Element:span
					"chat_message"
				Element:span
					:
				Element:span
					"{{title}} and of course {{description}}"
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					We will generate the following output:
			Node:
			(type) c
			(layer)1
				Element:pre
				Element:span
					{
				Element:span
					"talking_user"
				Element:span
					:
				Element:span
					"Larry"
				Element:span
					,
				Element:span
					"chat_message"
				Element:span
					:
				Element:span
					"Hello world! and of course It's a beautiful day!"
				Element:span
					}
			Node:
			(type) c
			(layer)1
				Element:p
					The keys to put between the {{}} come from the keys you specify when you setup
					↑ Was this documentation useful?
				Element:a
					action fields
					,
				Element:a
					trigger fields
					, and
				Element:a
					authentication fields
					.
			Node:
			(type) c
			(layer)1
				Element:span
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) h1
			(layer)1
				Element:h1
					Versions Changelist
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					Below is a changelog of the major releases of the Zapier Developer Platform. Each release has a summary of the new features added and any breaking changes that were made.
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Version 2 (2015-07-31)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:blockquote
				Element:p
					To enable V2 -
				Element:a
					contact us
					so we can help you go through the process.
			Node:
			(type) c
			(layer)1
				Element:p
					This is a backward incompatible update to the Developer Platform. It adds several new features and fixes some of the limitations of the first version.
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
					Apps can now have
				Element:a
					Searches
					. A Search is used to find individual records by a field (say finding a contact by name).
				Element:ul
				Element:li
					Searches can be linked with Actions to create a
				Element:a
					Search or Create
					flow, giving the user a way to search for an item, and if it doesn't exist, create it.
				Element:li
					Searches can be used to power action fields, similar to Dynamic Dropdowns. Users input data to the field which is used to search for items, and a given data element returned from the search result (such as
				Element:code
					id
					) is used in place of their input.
				Element:li
					Fields can now have the “List” property defined through the UI. Before this was only possible to set via Scripting.
				Element:li
					Action fields have a “Parent Key” option that enables line item support.
				Element:li
					Fields now have a "Placeholder" option that operates solely as an HTML5 style placeholder - it is only for helping the user understand what will happen if they enter nothing in the given field.
				Element:li
				Element:strong
					Breaking Change
					Scripting can no longer access
				Element:code
					trigger_data
					from
				Element:code
					bundle
					in
				Element:code
					pre_write
					and
				Element:code
					post_write
					.
				Element:li
				Element:strong
					Breaking Change
					Scripting can no longer access
				Element:code
					trigger
					and
				Element:code
					action
					from
				Element:code
					bundle.zap
					.
				Element:li
				Element:strong
					Breaking Change
					Scripting code now runs under JS strict mode (
				Element:code
					'use strict';
					), so developer should verify their code still executes correctly (the built in code editor runs jshint - so check there!)
				Element:li
				Element:strong
					Breaking Change
					Data mapped into Action Fields is always coerced according to the field's type
				Element:li
				Element:strong
					Breaking Change
					Data entering actions is no longer flattened into a string. This means lists and dictionaries will pass through to actions intact rather than being converted to CSV and 'key|value' respectively. If there is existing Scripting code that does any sort of parsing on those values, it will need to be updated to handle the new structure (likely this means deleting code that was expanding the strings back into arrays and dictionaries).
				Element:li
				Element:strong
					Breaking Change
					We now automatically include a
				Element:code
					state
					parameter on the Authorization URL for apps that use OAuth2.
				Element:li
				Element:strong
					Bug Fix
					Trigger fields passed into custom fields, REST hook and catch hook methods are always coerced according to the field's type
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
				Element:h2
					Version 1 (2012-08-01)
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:p
					The initial launch of the platform.
					↑ Was this documentation useful?
			Node:
			(type) c
			(layer)1
				Element:span
					Can't find what you're looking for? We'd love to help.
				Element:a
					Yes
				Element:a
					No
			Node:
			(type) c
			(layer)1
				Element:a
					Send us a message
					. Get Help
			Node:
			(type) c
			(layer)1
				Element:noscript
				Element:img
