Node:
(type) c
(layer)0
	Element:body
			Node:
			(type) h1
			(layer)1
				Element:h1
					Built-in Functions, Tools & Meta Information
				Element:a
					#
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Available Libraries
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:p
								Our scripting engine uses JavaScript. As you'd expect, it provides the standard JavaScript interfaces (JSON, Math, Date and more) as well as
							Element:code
								$
								for jQuery (1.8.3),
							Element:code
								_
								for Underscore (1.4.4), and
							Element:code
								moment
								for Moment.js (2.0.0 with timezone),
							Element:code
								crypto
								, and
							Element:code
								async
								(0.2.9). Plus, it has some handy Zapier specific tools on the
							Element:code
								z
								object!
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Unavailable Objects
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:p
								Some "common" objects you might expect to find we don't provide access to include
							Element:code
								root
								,
							Element:code
								child_process
								,
							Element:code
								Function
								,
							Element:code
								module
								,
							Element:code
								process
								,
							Element:code
								global
								, and
							Element:code
								setInterval
								(they'll be
							Element:code
								undefined
								at runtime).
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Making Outbound Requests (z.request)
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								z.request
								function allows you to make external calls. It performs in a synchronous manner for ease of use, but also provides standard asynchronous features as well if you pass an optional callback.
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								z.request(request, [callback])
						Node:
						(type) c
						(layer)2
							Element:p
								It takes a required argument called
							Element:code
								request
								(which matches what
							Element:code
								bundle.request
								gives in most other examples):
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								var
							Element:span
								request
							Element:span
								=
							Element:span
								{
							Element:span
								'method'
							Element:span
								:
							Element:span
								'POST'
							Element:span
								,
							Element:span
								'url'
							Element:span
								:
							Element:span
								'http://example.com/'
							Element:span
								,
							Element:span
								'params'
							Element:span
								:
							Element:span
								{
							Element:span
								'query'
							Element:span
								:
							Element:span
								'string'
							Element:span
								,
							Element:span
								'page'
							Element:span
								:
							Element:span
								'1'
							Element:span
								},
							Element:span
								'headers'
							Element:span
								:
							Element:span
								{
							Element:span
								'Content-Type'
							Element:span
								:
							Element:span
								'application/content'
							Element:span
								,
							Element:span
								'Accept'
							Element:span
								:
							Element:span
								'application/json'
							Element:span
								},
							Element:span
								'auth'
							Element:span
								:
							Element:span
								[
							Element:span
								'username'
							Element:span
								,
							Element:span
								'password'
							Element:span
								],
							Element:span
								'data'
							Element:span
								:
							Element:span
								'{"hello":"world!"}'
							Element:span
								};
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								callback
								argument is optional, but will be called with a standard
							Element:code
								callback(err, response)
								.
						Node:
						(type) c
						(layer)2
							Element:p
								The returned
							Element:code
								response
								object is fairly simple (and matches what
							Element:code
								bundle.response
								is in all other examples):
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								{
							Element:span
								"status_code"
							Element:span
								:
							Element:span
								200
							Element:span
								,
							Element:span
								"headers"
							Element:span
								:
							Element:span
								{
							Element:span
								"Connection"
							Element:span
								:
							Element:span
								"close"
							Element:span
								,
							Element:span
								"Content-Type"
							Element:span
								:
							Element:span
								"application/content"
							Element:span
								,
							Element:span
								"Content-Length"
							Element:span
								:
							Element:span
								"18"
							Element:span
								},
							Element:span
								"content"
							Element:span
								:
							Element:span
								"{\"hello\":\"world!\"}"
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								Here is a simple example:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								// let's call http://httpbin.org/get?hello=world with an extra header
							Element:span
								var
							Element:span
								request
							Element:span
								=
							Element:span
								{
							Element:span
								'method'
							Element:span
								:
							Element:span
								'GET'
							Element:span
								,
							Element:span
								'url'
							Element:span
								:
							Element:span
								'http://httpbin.org/get'
							Element:span
								,
							Element:span
								'params'
							Element:span
								:
							Element:span
								{
							Element:span
								'hello'
							Element:span
								:
							Element:span
								'world'
							Element:span
								},
							Element:span
								'headers'
							Element:span
								:
							Element:span
								{
							Element:span
								'Accept'
							Element:span
								:
							Element:span
								'application/json'
							Element:span
								},
							Element:span
								'auth'
							Element:span
								:
							Element:span
								null
							Element:span
								,
							Element:span
								'data'
							Element:span
								:
							Element:span
								null
							Element:span
								};
							Element:span
								// perform synchronously
							Element:span
								var
							Element:span
								response
							Element:span
								=
							Element:span
								z
							Element:span
								.
							Element:span
								request
							Element:span
								(
							Element:span
								request
							Element:span
								);
							Element:span
								console
							Element:span
								.
							Element:span
								log
							Element:span
								(
							Element:span
								'Status: '
							Element:span
								+
							Element:span
								response
							Element:span
								.
							Element:span
								status_code
							Element:span
								);
							Element:span
								console
							Element:span
								.
							Element:span
								log
							Element:span
								(
							Element:span
								'Headers: '
							Element:span
								+
							Element:span
								JSON
							Element:span
								.
							Element:span
								stringify
							Element:span
								(
							Element:span
								response
							Element:span
								.
							Element:span
								headers
							Element:span
								));
							Element:span
								console
							Element:span
								.
							Element:span
								log
							Element:span
								(
							Element:span
								'Content/Body: '
							Element:span
								+
							Element:span
								response
							Element:span
								.
							Element:span
								content
							Element:span
								);
							Element:span
								// perform asynchronously
							Element:span
								z
							Element:span
								.
							Element:span
								request
							Element:span
								(
							Element:span
								request
							Element:span
								,
							Element:span
								function
							Element:span
								(
							Element:span
								err
							Element:span
								,
							Element:span
								response
							Element:span
								){
							Element:span
								console
							Element:span
								.
							Element:span
								log
							Element:span
								(
							Element:span
								'Status: '
							Element:span
								+
							Element:span
								response
							Element:span
								.
							Element:span
								status_code
							Element:span
								);
							Element:span
								console
							Element:span
								.
							Element:span
								log
							Element:span
								(
							Element:span
								'Headers: '
							Element:span
								+
							Element:span
								JSON
							Element:span
								.
							Element:span
								stringify
							Element:span
								(
							Element:span
								response
							Element:span
								.
							Element:span
								headers
							Element:span
								));
							Element:span
								console
							Element:span
								.
							Element:span
								log
							Element:span
								(
							Element:span
								'Content/Body: '
							Element:span
								+
							Element:span
								response
							Element:span
								.
							Element:span
								content
							Element:span
								);
							Element:span
								});
						Node:
						(type) c
						(layer)2
							Element:p
								Please note that you only have about 30 seconds to make all your requests and return. So don't take too long!
						Node:
						(type) c
						(layer)2
							Element:blockquote
							Element:p
								If you need to do lots of extra API calls, especially in a loop, you should look our hydration routine.
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Hashing
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:p
								We support both hashing and HMAC hashing.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								// z.hash(algorithm, string, encoding="hex", input_encoding="binary")
							Element:span
								var
							Element:span
								hash
							Element:span
								=
							Element:span
								z
							Element:span
								.
							Element:span
								hash
							Element:span
								(
							Element:span
								'sha256'
							Element:span
								,
							Element:span
								"my awesome string"
							Element:span
								);
							Element:span
								// z.hmac(algorithm, key, string, encoding="hex")
							Element:span
								var
							Element:span
								hmac_hash
							Element:span
								=
							Element:span
								z
							Element:span
								.
							Element:span
								hmac
							Element:span
								(
							Element:span
								'sha256'
							Element:span
								,
							Element:span
								'key'
							Element:span
								,
							Element:span
								'string'
							Element:span
								);
							Element:span
								// Node.js crypto's library does not officially document using input encodings with hmac, but you can do the following:
							Element:span
								var
							Element:span
								crypto
							Element:span
								=
							Element:span
								require
							Element:span
								(
							Element:span
								'crypto'
							Element:span
								);
							Element:span
								crypto
							Element:span
								.
							Element:span
								createHmac
							Element:span
								(
							Element:span
								'sha256'
							Element:span
								,
							Element:span
								'key'
							Element:span
								).
							Element:span
								update
							Element:span
								(
							Element:span
								'string'
							Element:span
								,
							Element:span
								'input_encoding'
							Element:span
								).
							Element:span
								digest
							Element:span
								(
							Element:span
								'encoding'
							Element:span
								);
						Node:
						(type) c
						(layer)2
							Element:p
								For output encoding (the
							Element:code
								encoding
								parameter) we default to
							Element:code
								hex
								and also support
							Element:code
								base64
								as a parameter value. For input encoding (the
							Element:code
								input_encoding
								parameter) we default to
							Element:code
								binary
								and also support
							Element:code
								utf8
								as a parameter value. You should use
							Element:code
								utf8
								if you expect data to be hashed that may include UTF8 characters.
						Node:
						(type) c
						(layer)2
							Element:p
								The following hash algorithms are supported:
						Node:
						(type) c
						(layer)2
							Element:p
							Element:code
								DSA-SHA1-old
								,
							Element:code
								dsa
								,
							Element:code
								dsa-sha
								,
							Element:code
								dsa-sha1
								,
							Element:code
								dsaEncryption
								,
							Element:code
								dsaWithSHA
								,
							Element:code
								dsaWithSHA1
								,
							Element:code
								dss1
								,
							Element:code
								ecdsa-with-SHA1
								,
							Element:code
								md4
								,
							Element:code
								md4WithRSAEncryption
								,
							Element:code
								md5
								,
							Element:code
								md5WithRSAEncryption
								,
							Element:code
								mdc2
								,
							Element:code
								mdc2WithRSA
								,
							Element:code
								ripemd
								,
							Element:code
								ripemd160
								,
							Element:code
								ripemd160WithRSA
								,
							Element:code
								rmd160
								,
							Element:code
								rsa-md4
								,
							Element:code
								rsa-md5
								,
							Element:code
								rsa-mdc2
								,
							Element:code
								rsa-ripemd160
								,
							Element:code
								rsa-sha
								,
							Element:code
								rsa-sha1
								,
							Element:code
								rsa-sha1-2
								,
							Element:code
								rsa-sha224
								,
							Element:code
								rsa-sha256
								,
							Element:code
								rsa-sha384
								,
							Element:code
								rsa-sha512
								,
							Element:code
								sha
								,
							Element:code
								sha1
								,
							Element:code
								sha224
								,
							Element:code
								sha256
								,
							Element:code
								sha384
								,
							Element:code
								sha512
								,
							Element:code
								ssl2-md5
								,
							Element:code
								ssl3-md5
								,
							Element:code
								ssl3-sha1
								,
							Element:code
								whirlpool
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Base 64 Encoding
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:p
								If you're looking to turn some text to base64 for something like Basic Auth or otherwise, use this simple function available from Node.js:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								var
							Element:span
								b64data
							Element:span
								=
							Element:span
								btoa
							Element:span
								(
							Element:span
								"this is my string to turn into base64"
							Element:span
								);
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Hydration & Dehydration
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:blockquote
							Element:p
								Hydration & dehydration is an experimental feature! Contact us if you need a hand at
							Element:a
								contact@zapier.com
								.
						Node:
						(type) c
						(layer)2
							Element:p
								Dehydration is what we call the creation of a pointer to some data, this is what you'll normally use to provide data that may not be needed now but could the future.
						Node:
						(type) c
						(layer)2
							Element:p
								Hydration is the opposite of dehydration. It is the consumption of a pointer that returns data. Let's show an example!
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								var
							Element:span
								Zap
							Element:span
								=
							Element:span
								{
							Element:span
								get_contact
							Element:span
								:
							Element:span
								function
							Element:span
								(
							Element:span
								bundle
							Element:span
								)
							Element:span
								{
							Element:span
								/*
							Element:span
								Argument:
							Element:span
								bundle.auth_fields: <object>
							Element:span
								bundle.zap: <object> # info about the zap
							Element:span
								Anything else you might need, like bundle.request.headers, will need to be passed in when you call z.dehydrate()
							Element:span
								*/
							Element:span
								var
							Element:span
								contact
							Element:span
								=
							Element:span
								JSON
							Element:span
								.
							Element:span
								parse
							Element:span
								(
							Element:span
								z
							Element:span
								.
							Element:span
								request
							Element:span
								({
							Element:span
								method
							Element:span
								:
							Element:span
								'GET'
							Element:span
								,
							Element:span
								url
							Element:span
								:
							Element:span
								'https://api.fancycrm.com/v1/contacts/'
							Element:span
								+
							Element:span
								bundle
							Element:span
								.
							Element:span
								contact_id
							Element:span
								+
							Element:span
								'.json'
							Element:span
								,
							Element:span
								auth
							Element:span
								:
							Element:span
								[
							Element:span
								bundle
							Element:span
								.
							Element:span
								auth_fields
							Element:span
								.
							Element:span
								api_key
							Element:span
								,
							Element:span
								''
							Element:span
								]
							Element:span
								// you'll need to handle auth
							Element:span
								}).
							Element:span
								content
							Element:span
								)
							Element:span
								||
							Element:span
								{};
							Element:span
								return
							Element:span
								contact
							Element:span
								;
							Element:span
								},
							Element:span
								deal_post_poll
							Element:span
								:
							Element:span
								function
							Element:span
								(
							Element:span
								bundle
							Element:span
								)
							Element:span
								{
							Element:span
								var
							Element:span
								deals
							Element:span
								=
							Element:span
								JSON
							Element:span
								.
							Element:span
								parse
							Element:span
								(
							Element:span
								bundle
							Element:span
								.
							Element:span
								response
							Element:span
								.
							Element:span
								content
							Element:span
								);
							Element:span
								return
							Element:span
								_
							Element:span
								.
							Element:span
								map
							Element:span
								(
							Element:span
								deals
							Element:span
								,
							Element:span
								function
							Element:span
								(
							Element:span
								deal
							Element:span
								)
							Element:span
								{
							Element:span
								// this delays Zap.get_contact({contact_id: deal.contact_id, auth_fields: bundle_auth_fields})
							Element:span
								deal
							Element:span
								.
							Element:span
								contact
							Element:span
								=
							Element:span
								z
							Element:span
								.
							Element:span
								dehydrate
							Element:span
								(
							Element:span
								'get_contact'
							Element:span
								,
							Element:span
								{
							Element:span
								contact_id
							Element:span
								:
							Element:span
								deal
							Element:span
								.
							Element:span
								contact_id
							Element:span
								});
							Element:span
								return
							Element:span
								deal
							Element:span
								;
							Element:span
								});
							Element:span
								}
							Element:span
								};
						Node:
						(type) c
						(layer)2
							Element:p
								In the example above,
							Element:code
								get_contact
								will not be called when post_poll is called. Instead, a unique hash is created and stored in place of
							Element:code
								deal.contact
								.
						Node:
						(type) c
						(layer)2
							Element:p
								There are two scenarios when
							Element:code
								get_contact
								will then be called and "hydrated".
						Node:
						(type) c
						(layer)2
							Element:ol
							Element:li
							Element:p
								When a user is first setting up their Zap in the UI and accessing fields (because
							Element:code
								deal.contact
								may have keys to choose from on itself).
							Element:li
							Element:p
								When a user's Zap tries to send
							Element:code
								deal.contact
								out to another app.
						Node:
						(type) c
						(layer)2
							Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Files
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:blockquote
							Element:p
								Files are an experimental feature! You can read more about files here:
							Element:a
								files reference
								.
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Dehydrating Files
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											Dehydration is what we call the creation of a pointer to data, this is what you'll normally use in triggers to provide binary data out of band to Zapier. The idea is simple: you don't want to download all the attachments from all 100 records in a poll - that would take way too long and would be wasteful! So we offer a handy way to create pointers that we can consume "on-demand".
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											// you can pass along urls and extra request information
										Element:span
											// important: dehydrateFile will not download the file immediately!
										Element:span
											// it just creates a pointer that our system understands so it can
										Element:span
											// get the file on demand if it is needed
										Element:span
											// if you just provide the url, we'll include any standard api
										Element:span
											// headers or querystrings you configure for oauth or similar
										Element:span
											var
										Element:span
											url
										Element:span
											=
										Element:span
											'https://example.com/test.txt'
										Element:span
											;
										Element:span
											var
										Element:span
											filePointer
										Element:span
											=
										Element:span
											z
										Element:span
											.
										Element:span
											dehydrateFile
										Element:span
											(
										Element:span
											url
										Element:span
											);
										Element:span
											// you can provide extra information about the request
										Element:span
											// but this will leave off any oauth or similar headers!
										Element:span
											var
										Element:span
											filePointer
										Element:span
											=
										Element:span
											z
										Element:span
											.
										Element:span
											dehydrateFile
										Element:span
											(
										Element:span
											url
										Element:span
											,
										Element:span
											{
										Element:span
											method
										Element:span
											:
										Element:span
											'post'
										Element:span
											,
										Element:span
											params
										Element:span
											:
										Element:span
											{
										Element:span
											custom
										Element:span
											:
										Element:span
											'param'
										Element:span
											},
										Element:span
											headers
										Element:span
											:
										Element:span
											{
										Element:span
											'X-Download-Key'
										Element:span
											:
										Element:span
											'abcdef1234567890'
										Element:span
											}
										Element:span
											},
										Element:span
											{
										Element:span
											name
										Element:span
											:
										Element:span
											'mytextfile.txt'
										Element:span
											,
										Element:span
											// if blank we will guess/inspect!
										Element:span
											length
										Element:span
											:
										Element:span
											123
										Element:span
											// if blank we will guess/inspect!
										Element:span
											});
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Hydrating Files
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											The scripting portion of hydration in actions is incomplete - right now your API will need to adhere to our multipart pattern as described in our
										Element:a
											files reference documentation
											.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Bundle Details
							Element:a
								#
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Raw URL via
										Element:code
											bundle.url_raw
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											bundle.url_raw
											is simply the unrendered version of the URL with
										Element:code
											{{curlies}}
											still intact.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Auth Fields via
										Element:code
											bundle.auth_fields
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											bundle.auth_fields
											is a javascript object that matches the authentication settings provided by the user when the API is connected. For example, if you have an
										Element:a
											authentication field
											of
										Element:code
											api_key
											and
										Element:code
											subdomain
											you can expect:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											{
										Element:span
											"api_key"
										Element:span
											:
										Element:span
											"fc5e038d38a57032085441e7fe7010b0"
										Element:span
											,
										Element:span
											"subdomain"
										Element:span
											:
										Element:span
											"example"
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Rendered Fields via
										Element:code
											bundle.trigger_fields
											or
										Element:code
											bundle.action_fields
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											Both
										Element:code
											bundle.trigger_fields
											and
										Element:code
											bundle.action_fields
											are javascript objects that surface the data given by a user to power a part of a zap. This is after rendering
										Element:code
											{{curlies}}
											. These follow the
										Element:a
											trigger fields
											or
										Element:a
											action fields
											you define. For example, maybe you have a field with a key
										Element:code
											list_id
											and
										Element:code
											name
											:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											{
										Element:span
											"list_id"
										Element:span
											:
										Element:span
											"1234"
										Element:span
											,
										Element:span
											"name"
										Element:span
											:
										Element:span
											"Joe Blow"
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:p
											For actions, this will prune out any fields you chose not to send in the JSON. Use
										Element:code
											bundle.action_fields_full
											if you want them included as well.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Raw Fields via
										Element:code
											bundle.trigger_fields_raw
											or
										Element:code
											bundle.action_fields_raw
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											Both
										Element:code
											bundle.trigger_fields_raw
											or
										Element:code
											bundle.action_fields_raw
											are javascript objects that surface the data given by a user to power a part of a zap. This is before rendering
										Element:code
											{{curlies}}
											. These follow the
										Element:a
											trigger fields
											or
										Element:a
											action fields
											you define. For example, maybe you have a field with a key
										Element:code
											list_id
											:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											{
										Element:span
											"list_id"
										Element:span
											:
										Element:span
											"1234"
										Element:span
											,
										Element:span
											"name"
										Element:span
											:
										Element:span
											"{{first_name}} {{last_name}}"
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:p
											For actions, this will prune out any fields you chose not to send in the JSON.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Trigger Details via
										Element:code
											bundle.trigger_data
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											This is deprecated and will be going away entirely soon. Instead, use standard
										Element:a
											Action Fields
											which the user maps, to access trigger data.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Webhook Payload via
										Element:code
											bundle.cleaned_request
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											bundle.cleaned_request
											is our best guess at the parsed payload. We do our best to parse JSON, XML and form-encoded data into respective javascript objects. If we cannot parse it correctly - look into
										Element:code
											bundle.request.content
											and parse it yourself.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Zap Details via
										Element:code
											bundle.zap
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											bundle.zap
											object contains extra information about the zap (FYI: you may not see this information in debug bundles until the
										Element:code
											zap
											is referenced at least once in your script):
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											{
										Element:span
											"name"
										Element:span
											:
										Element:span
											"My Fancy Zap Title"
										Element:span
											,
										Element:span
											"live"
										Element:span
											:
										Element:span
											false
										Element:span
											,
										Element:span
											"link"
										Element:span
											:
										Element:span
											"https://zapier.com/app/edit/12345"
										Element:span
											,
										Element:span
											"user"
										Element:span
											:
										Element:span
											{
										Element:span
											"timezone"
										Element:span
											:
										Element:span
											"America/Denver"
										Element:span
											,
										Element:span
											},
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:p
											You can access the information like this:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											var
										Element:span
											Zap
										Element:span
											=
										Element:span
											{
										Element:span
											any_old_pre_poll
										Element:span
											:
										Element:span
											function
										Element:span
											(
										Element:span
											bundle
										Element:span
											)
										Element:span
											{
										Element:span
											var
										Element:span
											zap
										Element:span
											=
										Element:span
											bundle
										Element:span
											.
										Element:span
											zap
										Element:span
											;
										Element:span
											var
										Element:span
											message
										Element:span
											=
										Element:span
											'The Zap title is '
										Element:span
											+
										Element:span
											zap
										Element:span
											.
										Element:span
											name
										Element:span
											'!'
										Element:span
											;
										Element:span
											// message == "The Zap title is My Fancy Zap Title!"
										Element:span
											return
										Element:span
											bundle
										Element:span
											.
										Element:span
											request
										Element:span
											;
										Element:span
											}
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Extra Request Info via
										Element:code
											bundle.meta
										Element:a
											#
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											bundle.meta
											object contains some runtime information about the Zap which you can use.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											{
										Element:span
											"frontend"
										Element:span
											:
										Element:span
											true
										Element:span
											,
										Element:span
											// if true, it's being done through the Zap editor/setup
										Element:span
											"prefill"
										Element:span
											:
										Element:span
											false
										Element:span
											,
										Element:span
											// if true, this poll is running as a prefill (dynamic dropdown)
										Element:span
											// for another poll
										Element:span
											"filter"
										Element:span
											:
										Element:span
											false
										Element:span
											,
										Element:span
											// if true, this poll will be filtered afterwards
										Element:span
											"hydrate"
										Element:span
											:
										Element:span
											true
										Element:span
											,
										Element:span
											// if true, the results from this poll will be hydrated
										Element:span
											"limit"
										Element:span
											:
										Element:span
											5
										Element:span
											,
										Element:span
											// how many items you should limit the API call to for
										Element:span
											// performance reasons. a value of -1 means not limited
										Element:span
											"test_poll"
										Element:span
											:
										Element:span
											false
										Element:span
											,
										Element:span
											// if true, means this API call came from the user
										Element:span
											// testing their account in the UI
										Element:span
											"standard_poll"
										Element:span
											:
										Element:span
											true
										Element:span
											,
										Element:span
											// opposite of bundle.meta.test_poll
										Element:span
											"first_poll"
										Element:span
											:
										Element:span
											false
										Element:span
											,
										Element:span
											// if true, means this API call is our initial check for
										Element:span
											// items in the API when the Zap is turned on
										Element:span
											"page"
										Element:span
											:
										Element:span
											0
										Element:span
											// which page of API results you should return, useful for
										Element:span
											// paging backwards for dynamic dropdowns. It is 0-indexed
										Element:span
											// (add 1 via JS if your paging scheme is 1-indexed)
										Element:span
											// note this is only available for dynamic dropdowns,
										Element:span
											// when bundle.meta.frontend === true
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:blockquote
										Element:p
											Use bundle.meta.page to implement pagination - this is especially important for triggers that power dropdowns.
									Node:
									(type) c
									(layer)3
										Element:p
											You can access the information for limited pagination features like this:
									Node:
									(type) c
									(layer)3
										Element:pre
											↑ Was this documentation useful?
										Element:span
											var
										Element:span
											Zap
										Element:span
											=
										Element:span
											{
										Element:span
											any_old_pre_poll
										Element:span
											:
										Element:span
											function
										Element:span
											(
										Element:span
											bundle
										Element:span
											)
										Element:span
											{
										Element:span
											// adds ?page=0 to URL querystring
										Element:span
											bundle
										Element:span
											.
										Element:span
											request
										Element:span
											.
										Element:span
											params
										Element:span
											.
										Element:span
											page
										Element:span
											=
										Element:span
											bundle
										Element:span
											.
										Element:span
											meta
										Element:span
											.
										Element:span
											page
										Element:span
											return
										Element:span
											bundle
										Element:span
											.
										Element:span
											request
										Element:span
											;
										Element:span
											}
										Element:span
											}
									Node:
									(type) c
									(layer)3
										Element:span
											Can't find what you're looking for? We'd love to help.
										Element:a
											Yes
										Element:a
											No
									Node:
									(type) c
									(layer)3
										Element:a
											Send us a message
											. Get Help
									Node:
									(type) c
									(layer)3
										Element:noscript
										Element:img
