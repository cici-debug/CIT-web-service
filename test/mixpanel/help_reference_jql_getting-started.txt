Node:
(type) c
(layer)0
	Element:body
			Node:
			(type) h1
			(layer)1
				Element:h1
					JQL: Getting started guide
			Node:
			(type) c
			(layer)1
				Element:p
					In this section, we'll explore the core concepts of JQL by working through a real world example.
			Node:
			(type) c
			(layer)1
				Element:p
					Imagine we're a freemium SaaS business with two paid plans, Basic and Premium, and we want to understand how many of each plan were purchased, and how long it took users to convert from free to paid.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Running example queries
						Node:
						(type) c
						(layer)2
							Element:p
								To help you work through this example, we've populated a demo project with some data you can query. At any point in the tutorial, you can execute the current version of the code to see how it works.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Try out JQL using our playground
									Node:
									(type) c
									(layer)3
										Element:p
											To run a query from your browser using test data, you can use this
										Element:a
											query console
											. Just paste in the example code and hit "Run query".
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Running & saving queries within Mixpanel
									Node:
									(type) c
									(layer)3
										Element:p
											When you're ready to run queries against your own data in Mixpanel, just log in, go to Applications, and click on the application "JQL" to be able to run queries interactively and save them so your co-workers can run them too.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Running queries from the command line: Mac OS X or Linux
									Node:
									(type) c
									(layer)3
										Element:p
											JQL can be executed via an HTTP endpoint, with JQL query provided in a body of a POST request. With the query saved in
										Element:span
											query.js
											file, the following command uses the cURL utility to upload our query and return back the results, in JSON format.
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:span
											# sends the JQL code in `query.js` to the api
										Element:span
											# to a project with sample data for this tutorial
											curl https://mixpanel.com/api/2.0/jql
										Element:span
											\
											-u ce08d087255d5ceec741819a57174ce5:
										Element:span
											\
											--data-urlencode script@query.js
										Element:span
											|
											python -m json.tool
									Node:
									(type) c
									(layer)3
										Element:p
											In order to authenticate requests the
										Element:span
											-u
											flag lets us pass a username and password. To query the JQL API for your project, use its API secret as the username, with a blank password.
									Node:
									(type) c
									(layer)3
										Element:p
											To learn more about Query Authentication, look at the
										Element:a
											Data Export API
											documentation.
									Node:
									(type) c
									(layer)3
										Element:p
											If you get an error that says
										Element:code
											Missing required parameter: script
											, you probably forgot to save your code in the
										Element:span
											query.js
											file.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Step 1: Querying events
						Node:
						(type) c
						(layer)2
							Element:p
								To get started, let's look at the simplest possible JQL query, which retrieves all of the events between two dates:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								})
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								There are two requirements that all JQL queries must fulfill:
						Node:
						(type) c
						(layer)2
							Element:ol
							Element:li
								They must define a
							Element:span
								main()
								function. We compile your JavaScript and execute the
							Element:span
								main()
								function against your raw data to perform the analysis
							Element:li
								The main() function must call the
							Element:span
								or
							Element:a
								Events()
							Element:span
								function to select a collection to analyze
							Element:a
								People()
						Node:
						(type) c
						(layer)2
							Element:p
								As you can see, our simple example fulfills both of these criteria and no more. It uses the events collection. When you run this minimal query, it will return a JSON list of all events sent to your project between Jan 1 and Jan 7, 2016:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								[
							Element:span
								{
							Element:span
								"name"
							Element:span
								:
							Element:span
								"login"
							Element:span
								,
							Element:span
								"distinct_id"
							Element:span
								:
							Element:span
								4
							Element:span
								,
							Element:span
								"time"
							Element:span
								:
							Element:span
								1420124166000
							Element:span
								,
							Element:span
								"properties"
							Element:span
								:
							Element:span
								{}
							Element:span
								},
							Element:span
								{
							Element:span
								"name"
							Element:span
								:
							Element:span
								"purchase"
							Element:span
								,
							Element:span
								"time"
							Element:span
								:
							Element:span
								1420120626000
							Element:span
								,
							Element:span
								"properties"
							Element:span
								:
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								"Basic"
							Element:span
								,
							Element:span
								"signup_date"
							Element:span
								:
							Element:span
								"2014-12-03"
							Element:span
								}
							Element:span
								},
							Element:span
								...
							Element:span
								// more events
							Element:span
								]
						Node:
						(type) c
						(layer)2
							Element:p
								The JQL framework revolves around two concepts:
							Element:strong
								collections
								and
							Element:strong
								transformations
								. A collection is a list of values which can be
							Element:em
								transformed
								into other collections to perform analyses and answer complex questions.
						Node:
						(type) c
						(layer)2
							Element:p
								One example transformation is
							Element:span
								, which is used to filter down a collection to the values you care about.
							Element:a
								filter()
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Step 2: Filtering the dataset
						Node:
						(type) c
						(layer)2
							Element:p
								We are only interested in "purchase" events, so the next step is to filter the events collection to just those events:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								}).
							Element:span
								filter
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								return
							Element:span
								event
							Element:span
								.
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								});
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								When you run this query, the output is still a list of events, but it's been filtered down to just the purchase events:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								[
							Element:span
								{
							Element:span
								"name"
							Element:span
								:
							Element:span
								"purchase"
							Element:span
								,
							Element:span
								"time"
							Element:span
								:
							Element:span
								1420120626000
							Element:span
								,
							Element:span
								"properties"
							Element:span
								:
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								"Basic"
							Element:span
								,
							Element:span
								"signup_date"
							Element:span
								:
							Element:span
								"2014-12-03"
							Element:span
								}
							Element:span
								},
							Element:span
								{
							Element:span
								"name"
							Element:span
								:
							Element:span
								"purchase"
							Element:span
								,
							Element:span
								"time"
							Element:span
								:
							Element:span
								1420380728000
							Element:span
								,
							Element:span
								"properties"
							Element:span
								:
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								"Basic"
							Element:span
								,
							Element:span
								"signup_date"
							Element:span
								:
							Element:span
								"2014-11-17"
							Element:span
								}
							Element:span
								},
							Element:span
								{
							Element:span
								"name"
							Element:span
								:
							Element:span
								"purchase"
							Element:span
								,
							Element:span
								"time"
							Element:span
								:
							Element:span
								1420603167000
							Element:span
								,
							Element:span
								"properties"
							Element:span
								:
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								"Premium"
							Element:span
								,
							Element:span
								"signup_date"
							Element:span
								:
							Element:span
								"2014-12-29"
							Element:span
								}
							Element:span
								},
							Element:span
								...
							Element:span
								// more purchase events
							Element:span
								]
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Step 3: Counting purchase events
						Node:
						(type) c
						(layer)2
							Element:p
								Now we can answer a real question: how many purchases were there? To do this, we can use another transformation,
							Element:span
								, which is used to reduce a collection to just a single value.
							Element:a
								reduce()
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								})
							Element:span
								.
							Element:span
								filter
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								return
							Element:span
								event
							Element:span
								.
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								})
							Element:span
								.
							Element:span
								reduce
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								accumulators
							Element:span
								,
							Element:span
								events
							Element:span
								)
							Element:span
								{
							Element:span
								var
							Element:span
								ret
							Element:span
								=
							Element:span
								events
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								// Add previously accumulated reduce function results.
							Element:span
								for
							Element:span
								(
							Element:span
								var
							Element:span
								i
							Element:span
								=
							Element:span
								0
							Element:span
								;
							Element:span
								i
							Element:span
								<
							Element:span
								accumulators
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								++
							Element:span
								i
							Element:span
								)
							Element:span
								{
							Element:span
								ret
							Element:span
								+=
							Element:span
								accumulators
							Element:span
								[
							Element:span
								i
							Element:span
								];
							Element:span
								}
							Element:span
								return
							Element:span
								ret
							Element:span
								;
							Element:span
								});
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								With result being equal to:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								[
							Element:span
								359
							Element:span
								]
						Node:
						(type) c
						(layer)2
							Element:p
								It's important to note that just calling
							Element:span
								by itself doesn't do anything -- you have to tell it what to do. Like other tranformations,
							Element:a
								reduce()
							Element:span
								has a required function argument - a
							Element:a
								reduce()
							Element:i
								reducer function
								. That function implements the following signature:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								(
							Element:span
								accumulators
							Element:span
								,
							Element:span
								items
							Element:span
								)
							Element:span
								{
							Element:span
								// Combine previously-aggregated "accumulators"
							Element:span
								// with new items and return the result.
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								A reducer function accepts two arguments: an array of its previous results (accumulators), and an array of items to reduce. The first argument - accumulators - is used to break down the initial set of values into many calls of the reducer function. JQL runs the reduction in a hierarchical fashion, where some subsets of inputs are reduced to accumulator values first, and multiple accumulator values are combined subsequently.
						Node:
						(type) c
						(layer)2
							Element:p
								Mixpanel provides a number of
							Element:a
								built-in reducer functions
								for frequently used aggregations. To just count the number of inputs, like in the example above, we can pass
							Element:span
								mixpanel.reducer.count()
								to
							Element:span
								.reduce():
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								,
							Element:span
								})
							Element:span
								.
							Element:span
								filter
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								event
							Element:span
								){
							Element:span
								return
							Element:span
								event
							Element:span
								.
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								;})
							Element:span
								.
							Element:span
								reduce
							Element:span
								(
							Element:span
								mixpanel
							Element:span
								.
							Element:span
								reducer
							Element:span
								.
							Element:span
								count
							Element:span
								());
							Element:span
								}
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Step 4: Grouping purchases by plan
						Node:
						(type) c
						(layer)2
							Element:p
								So, now we know how many purchases occurred during that week in January. But what did people buy? We have two plans, and we would like to see how many we sold of each.
						Node:
						(type) c
						(layer)2
							Element:p
								We can do that using another of our transformations,
							Element:span
								, to group these transactions by "plan" before counting them:
							Element:a
								groupBy()
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								})
							Element:span
								.
							Element:span
								filter
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								return
							Element:span
								event
							Element:span
								.
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								})
							Element:span
								.
							Element:span
								groupBy
							Element:span
								([
							Element:span
								"properties.plan"
							Element:span
								],
							Element:span
								mixpanel
							Element:span
								.
							Element:span
								reducer
							Element:span
								.
							Element:span
								count
							Element:span
								());
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								You will notice that we've replaced our
							Element:span
								transformation with
							Element:a
								reduce()
							Element:span
								.
							Element:a
								groupBy()
							Element:span
								is used to split a collection into groups. After splitting into groups, the reduce function passed to
							Element:a
								groupBy()
							Element:span
								is called on each group individually.
							Element:a
								groupBy()
						Node:
						(type) c
						(layer)2
							Element:p
								This query is getting complicated, so let's take a step back and reiterate what it's doing:
						Node:
						(type) c
						(layer)2
							Element:ol
							Element:li
								get all the events in a 7 day period
							Element:li
								filter down to just the purchase event
							Element:li
								group the events by their "plan" property
							Element:li
								count the number of events in each group
						Node:
						(type) c
						(layer)2
							Element:p
								When we execute the query, we get the following output:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								[
							Element:span
								{
							Element:span
								"value"
							Element:span
								:
							Element:span
								254
							Element:span
								,
							Element:span
								"key"
							Element:span
								:
							Element:span
								[
							Element:span
								"Basic"
							Element:span
								]
							Element:span
								},
							Element:span
								{
							Element:span
								"value"
							Element:span
								:
							Element:span
								105
							Element:span
								,
							Element:span
								"key"
							Element:span
								:
							Element:span
								[
							Element:span
								"Premium"
							Element:span
								]
							Element:span
								}
							Element:span
								]
						Node:
						(type) c
						(layer)2
							Element:p
								Now this is getting interesting. Our analysis shows that we sold 254 Basic plans and 105 Premium plans in that week.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Step 5: Calculating days between signup and purchase
						Node:
						(type) c
						(layer)2
							Element:p
								Let's take this one step further and answer a more complicated question: how long did it take users to sign up for these different plans? Does it take more or less time to convert a user to a Premium plan than a Basic plan?
						Node:
						(type) c
						(layer)2
							Element:p
								This will require us to calculate a "days to purchase" value for each event, which we can achieve with the "signup_date" property and the timestamp of the purchase event.
						Node:
						(type) c
						(layer)2
							Element:p
								We want to calculate the average days to purchase, but we can't go straight there. First, we have to get the components required to get an average: sum of numbers and the total count.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								})
							Element:span
								.
							Element:span
								filter
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								return
							Element:span
								event
							Element:span
								.
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								})
							Element:span
								.
							Element:span
								groupBy
							Element:span
								(
							Element:span
								[
							Element:span
								"properties.plan"
							Element:span
								],
							Element:span
								function
							Element:span
								(
							Element:span
								accumulators
							Element:span
								,
							Element:span
								items
							Element:span
								)
							Element:span
								{
							Element:span
								var
							Element:span
								ret
							Element:span
								=
							Element:span
								{
							Element:span
								sum
							Element:span
								:
							Element:span
								0.0
							Element:span
								,
							Element:span
								count
							Element:span
								:
							Element:span
								0.0
							Element:span
								};
							Element:span
								for
							Element:span
								(
							Element:span
								var
							Element:span
								i
							Element:span
								=
							Element:span
								0
							Element:span
								;
							Element:span
								i
							Element:span
								<
							Element:span
								accumulators
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								++
							Element:span
								i
							Element:span
								)
							Element:span
								{
							Element:span
								ret
							Element:span
								.
							Element:span
								sum
							Element:span
								+=
							Element:span
								accumulators
							Element:span
								[
							Element:span
								i
							Element:span
								].
							Element:span
								sum
							Element:span
								;
							Element:span
								ret
							Element:span
								.
							Element:span
								count
							Element:span
								+=
							Element:span
								accumulators
							Element:span
								[
							Element:span
								i
							Element:span
								].
							Element:span
								count
							Element:span
								;
							Element:span
								}
							Element:span
								ret
							Element:span
								.
							Element:span
								count
							Element:span
								+=
							Element:span
								items
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								for
							Element:span
								(
							Element:span
								var
							Element:span
								i
							Element:span
								=
							Element:span
								0
							Element:span
								;
							Element:span
								i
							Element:span
								<
							Element:span
								items
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								++
							Element:span
								i
							Element:span
								)
							Element:span
								{
							Element:span
								ret
							Element:span
								.
							Element:span
								sum
							Element:span
								+=
							Element:span
								getDaysSinceSignup
							Element:span
								(
							Element:span
								items
							Element:span
								[
							Element:span
								i
							Element:span
								]);
							Element:span
								}
							Element:span
								return
							Element:span
								ret
							Element:span
								;
							Element:span
								}
							Element:span
								);
							Element:span
								}
							Element:span
								// helper function to figure out how many days have
							Element:span
								// passed since the user signed up
							Element:span
								function
							Element:span
								getDaysSinceSignup
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								var
							Element:span
								signup_date
							Element:span
								=
							Element:span
								new
							Element:span
								Date
							Element:span
								(
							Element:span
								event
							Element:span
								.
							Element:span
								properties
							Element:span
								.
							Element:span
								signup_date
							Element:span
								),
							Element:span
								purchase_date
							Element:span
								=
							Element:span
								new
							Element:span
								Date
							Element:span
								(
							Element:span
								event
							Element:span
								.
							Element:span
								time
							Element:span
								),
							Element:span
								milliseconds_per_day
							Element:span
								=
							Element:span
								60
							Element:span
								*
							Element:span
								60
							Element:span
								*
							Element:span
								24
							Element:span
								*
							Element:span
								1000
							Element:span
								;
							Element:span
								// date subtraction yields milliseconds, so divide to get days
							Element:span
								return
							Element:span
								(
							Element:span
								purchase_date
							Element:span
								-
							Element:span
								signup_date
							Element:span
								)
							Element:span
								/
							Element:span
								milliseconds_per_day
							Element:span
								;
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								When we run this query, we see:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								[
							Element:span
								{
							Element:span
								"value"
							Element:span
								:
							Element:span
								{
							Element:span
								"count"
							Element:span
								:
							Element:span
								254
							Element:span
								,
							Element:span
								"sum"
							Element:span
								:
							Element:span
								14745.350497685187
							Element:span
								,
							Element:span
								},
							Element:span
								"key"
							Element:span
								:
							Element:span
								[
							Element:span
								"Basic"
							Element:span
								]
							Element:span
								},
							Element:span
								{
							Element:span
								"value"
							Element:span
								:
							Element:span
								{
							Element:span
								"count"
							Element:span
								:
							Element:span
								105
							Element:span
								,
							Element:span
								"sum"
							Element:span
								:
							Element:span
								3492.4220370370363
							Element:span
								,
							Element:span
								},
							Element:span
								"key"
							Element:span
								:
							Element:span
								[
							Element:span
								"Premium"
							Element:span
								]
							Element:span
								}
							Element:span
								]
						Node:
						(type) c
						(layer)2
							Element:p
								For the final step, we will use the
							Element:span
								transformation to get the average from the sum and count.
							Element:a
								map()
							Element:span
								is used any time we want to do a one-to-one transformation of a collection, by applying the provided function to each element of the collection.
							Element:a
								map()
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-01-07"
							Element:span
								})
							Element:span
								.
							Element:span
								filter
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								return
							Element:span
								event
							Element:span
								.
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								})
							Element:span
								.
							Element:span
								groupBy
							Element:span
								(
							Element:span
								[
							Element:span
								"properties.plan"
							Element:span
								],
							Element:span
								function
							Element:span
								(
							Element:span
								accumulators
							Element:span
								,
							Element:span
								items
							Element:span
								)
							Element:span
								{
							Element:span
								var
							Element:span
								ret
							Element:span
								=
							Element:span
								{
							Element:span
								sum
							Element:span
								:
							Element:span
								0.0
							Element:span
								,
							Element:span
								count
							Element:span
								:
							Element:span
								0.0
							Element:span
								};
							Element:span
								for
							Element:span
								(
							Element:span
								var
							Element:span
								i
							Element:span
								=
							Element:span
								0
							Element:span
								;
							Element:span
								i
							Element:span
								<
							Element:span
								accumulators
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								++
							Element:span
								i
							Element:span
								)
							Element:span
								{
							Element:span
								ret
							Element:span
								.
							Element:span
								sum
							Element:span
								+=
							Element:span
								accumulators
							Element:span
								[
							Element:span
								i
							Element:span
								].
							Element:span
								sum
							Element:span
								;
							Element:span
								ret
							Element:span
								.
							Element:span
								count
							Element:span
								+=
							Element:span
								accumulators
							Element:span
								[
							Element:span
								i
							Element:span
								].
							Element:span
								count
							Element:span
								;
							Element:span
								}
							Element:span
								ret
							Element:span
								.
							Element:span
								count
							Element:span
								+=
							Element:span
								items
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								for
							Element:span
								(
							Element:span
								var
							Element:span
								i
							Element:span
								=
							Element:span
								0
							Element:span
								;
							Element:span
								i
							Element:span
								<
							Element:span
								items
							Element:span
								.
							Element:span
								length
							Element:span
								;
							Element:span
								++
							Element:span
								i
							Element:span
								)
							Element:span
								{
							Element:span
								ret
							Element:span
								.
							Element:span
								sum
							Element:span
								+=
							Element:span
								getDaysSinceSignup
							Element:span
								(
							Element:span
								items
							Element:span
								[
							Element:span
								i
							Element:span
								]);
							Element:span
								}
							Element:span
								return
							Element:span
								ret
							Element:span
								;
							Element:span
								}
							Element:span
								)
							Element:span
								.
							Element:span
								map
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								item
							Element:span
								)
							Element:span
								{
							Element:span
								return
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								item
							Element:span
								.
							Element:span
								key
							Element:span
								[
							Element:span
								0
							Element:span
								],
							Element:span
								"avg days to purchase"
							Element:span
								:
							Element:span
								item
							Element:span
								.
							Element:span
								value
							Element:span
								.
							Element:span
								sum
							Element:span
								/
							Element:span
								item
							Element:span
								.
							Element:span
								value
							Element:span
								.
							Element:span
								count
							Element:span
								}
							Element:span
								});
							Element:span
								}
							Element:span
								function
							Element:span
								getDaysSinceSignup
							Element:span
								(
							Element:span
								event
							Element:span
								)
							Element:span
								{
							Element:span
								var
							Element:span
								signup_date
							Element:span
								=
							Element:span
								new
							Element:span
								Date
							Element:span
								(
							Element:span
								event
							Element:span
								.
							Element:span
								properties
							Element:span
								.
							Element:span
								signup_date
							Element:span
								),
							Element:span
								purchase_date
							Element:span
								=
							Element:span
								new
							Element:span
								Date
							Element:span
								(
							Element:span
								event
							Element:span
								.
							Element:span
								time
							Element:span
								),
							Element:span
								milliseconds_per_day
							Element:span
								=
							Element:span
								60
							Element:span
								*
							Element:span
								60
							Element:span
								*
							Element:span
								24
							Element:span
								*
							Element:span
								1000
							Element:span
								;
							Element:span
								// date subtraction yields milliseconds, so divide to get days
							Element:span
								return
							Element:span
								(
							Element:span
								purchase_date
							Element:span
								-
							Element:span
								signup_date
							Element:span
								)
							Element:span
								/
							Element:span
								milliseconds_per_day
							Element:span
								;
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								When we run this query, we will get the following output:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								[
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								"Basic"
							Element:span
								,
							Element:span
								"avg days to purchase"
							Element:span
								:
							Element:span
								58.05256101450859
							Element:span
								},
							Element:span
								{
							Element:span
								"plan"
							Element:span
								:
							Element:span
								"Premium"
							Element:span
								,
							Element:span
								"avg days to purchase"
							Element:span
								:
							Element:span
								33.261162257495585
							Element:span
								}
							Element:span
								]
						Node:
						(type) c
						(layer)2
							Element:p
						Node:
						(type) c
						(layer)2
							Element:p
								And that's the final result: users take about twice as long to buy a Basic plan as they do to purchase a Premium plan. This is a contrived example, but in the real world your next steps might be
						Node:
						(type) c
						(layer)2
							Element:ul
							Element:li
								calculate a distribution and figure out the median instead of the average
							Element:li
								dig in further to figure out what else is different between those user groups
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Step 6: Examining behavior patterns
						Node:
						(type) c
						(layer)2
							Element:p
								An analytic task is often centered around people behavior - sequences of actions performed by particular users. We are often interested in what events our users do, when these events happen, and in what order.
						Node:
						(type) c
						(layer)2
							Element:p
								JQL provides a
							Element:span
								transformation, which allows its argument function to look into the event history of each single user.
							Element:a
								groupByUser()
						Node:
						(type) c
						(layer)2
							Element:p
								The result of this transformation is a collection that contains one object per user. Each object has the structure outlined below:
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								{
							Element:span
								key
							Element:span
								:
							Element:span
								[
							Element:span
								<
							Element:span
								user
							Element:span
								distinct
							Element:span
								id
							Element:span
								>
							Element:span
								]
							Element:span
								value
							Element:span
								:
							Element:span
								<
							Element:span
								return
							Element:span
								value
							Element:span
								of
							Element:span
								transformation
							Element:span
								function
							Element:span
								>
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								In this tutorial step, we use
							Element:span
								to find out how often users are making purchase straight after logging in.
							Element:a
								groupByUser()
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								function
							Element:span
								main
							Element:span
								()
							Element:span
								{
							Element:span
								return
							Element:span
								Events
							Element:span
								({
							Element:span
								from_date
							Element:span
								:
							Element:span
								"2016-01-01"
							Element:span
								,
							Element:span
								to_date
							Element:span
								:
							Element:span
								"2016-02-01"
							Element:span
								}).
							Element:span
								groupByUser
							Element:span
								(
							Element:span
								function
							Element:span
								(
							Element:span
								state
							Element:span
								,
							Element:span
								events
							Element:span
								)
							Element:span
								{
							Element:span
								state
							Element:span
								=
							Element:span
								state
							Element:span
								||
							Element:span
								{
							Element:span
								last_login
							Element:span
								:
							Element:span
								false
							Element:span
								,
							Element:span
								count
							Element:span
								:
							Element:span
								0
							Element:span
								};
							Element:span
								if
							Element:span
								(
							Element:span
								events
							Element:span
								.
							Element:span
								length
							Element:span
								>
							Element:span
								0
							Element:span
								)
							Element:span
								{
							Element:span
								if
							Element:span
								(
							Element:span
								state
							Element:span
								.
							Element:span
								last_login
							Element:span
								&&
							Element:span
								events
							Element:span
								[
							Element:span
								0
							Element:span
								].
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								)
							Element:span
								{
							Element:span
								++
							Element:span
								state
							Element:span
								.
							Element:span
								count
							Element:span
								;
							Element:span
								}
							Element:span
								for
							Element:span
								(
							Element:span
								var
							Element:span
								i
							Element:span
								=
							Element:span
								0
							Element:span
								;
							Element:span
								i
							Element:span
								<
							Element:span
								events
							Element:span
								.
							Element:span
								length
							Element:span
								-
							Element:span
								1
							Element:span
								;
							Element:span
								++
							Element:span
								i
							Element:span
								)
							Element:span
								{
							Element:span
								if
							Element:span
								(
							Element:span
								events
							Element:span
								[
							Element:span
								i
							Element:span
								].
							Element:span
								name
							Element:span
								==
							Element:span
								"login"
							Element:span
								&&
							Element:span
								events
							Element:span
								[
							Element:span
								i
							Element:span
								+
							Element:span
								1
							Element:span
								].
							Element:span
								name
							Element:span
								==
							Element:span
								"purchase"
							Element:span
								)
							Element:span
								{
							Element:span
								++
							Element:span
								state
							Element:span
								.
							Element:span
								count
							Element:span
								;
							Element:span
								}
							Element:span
								}
							Element:span
								if
							Element:span
								(
							Element:span
								events
							Element:span
								[
							Element:span
								events
							Element:span
								.
							Element:span
								length
							Element:span
								-
							Element:span
								1
							Element:span
								].
							Element:span
								name
							Element:span
								==
							Element:span
								"login"
							Element:span
								)
							Element:span
								{
							Element:span
								state
							Element:span
								.
							Element:span
								last_login
							Element:span
								=
							Element:span
								true
							Element:span
								;
							Element:span
								}
							Element:span
								}
							Element:span
								return
							Element:span
								state
							Element:span
								;
							Element:span
								});
							Element:span
								}
						Node:
						(type) c
						(layer)2
							Element:p
								Note the the transformation function provided to
							Element:span
								takes two arguments - the
							Element:a
								groupByUser()
							Element:span
								state
								object and list of events. When the list of events that belong to a single user is long, JQL breaks down that list into multiple calls of the reducer function.
						Node:
						(type) c
						(layer)2
							Element:p
								In that case, the
							Element:span
								state
								argument is used for communication between calls - it contains the return value of the last call to the reducer function.
						Node:
						(type) c
						(layer)2
							Element:p
								In the example above, the output collection will consist of objects that include properties computed by the reducer function, in the
							Element:span
								value
								field.
						Node:
						(type) c
						(layer)2
							Element:pre
							Element:span
								{
							Element:span
								"value"
							Element:span
								:
							Element:span
								{
							Element:span
								"count"
							Element:span
								:
							Element:span
								4
							Element:span
								,
							Element:span
								"last_login"
							Element:span
								:
							Element:span
								false
							Element:span
								},
							Element:span
								"key"
							Element:span
								:
							Element:span
								[
							Element:span
								"3f151e8d-2bf4-4ecd-91e3-dbe8a8666eb0"
							Element:span
								]
							Element:span
								},
							Element:span
								{
							Element:span
								"value"
							Element:span
								:
							Element:span
								{
							Element:span
								"count"
							Element:span
								:
							Element:span
								2
							Element:span
								,
							Element:span
								"last_login"
							Element:span
								:
							Element:span
								false
							Element:span
								},
							Element:span
								"key"
							Element:span
								:
							Element:span
								[
							Element:span
								"da1ab57e-8fed-4ae4-9b65-5ea648b0f686"
							Element:span
								]
							Element:span
								}
							Element:span
								// More per-user records.
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Writing your own query
						Node:
						(type) c
						(layer)2
							Element:p
								This query walkthrough has introduced you to most of the concepts required to write your own JQL query. We covered:
						Node:
						(type) c
						(layer)2
							Element:p
						Node:
						(type) c
						(layer)2
							Element:ul
							Element:li
								The
							Element:span
								main()
								function, which is required in every JQL Query
							Element:li
								Selecting events using the
							Element:span
								function
							Element:a
								Events()
							Element:li
								Transforming data using the
							Element:span
								,
							Element:a
								map()
							Element:span
								,
							Element:a
								filter()
							Element:span
								, and
							Element:a
								groupBy()
							Element:span
								transformations.
							Element:a
								reduce()
							Element:li
								Analyzing user behavior with
							Element:span
							Element:a
								groupByUser()
						Node:
						(type) c
						(layer)2
							Element:p
								For more information about these concepts (and a few we haven't covered yet), please read the
								Document Sections
							Element:a
								full API reference
								.
						Node:
						(type) c
						(layer)2
							Element:ul
							Element:li
							Element:a
								Introduction
							Element:li
							Element:a
								Running example queries
							Element:li
							Element:a
								Querying events
							Element:li
							Element:a
								Filtering the dataset
							Element:li
							Element:a
								Counting purchase events
							Element:li
							Element:a
								Grouping by plan
							Element:li
							Element:a
								Calculating days to purchase
							Element:li
							Element:a
								Examining behavior patterns
							Element:li
							Element:a
								Writing your own query
