Node:
(type) c
(layer)0
	Element:body
			Node:
			(type) h1
			(layer)1
				Element:h1
					FAQ
			Node:
			(type) c
			(layer)1
				Element:p
					We know there's a lot to learn and read about all the integration points of the Slack platform. That's why we're giving you this. More to read, easier to skim.
			Node:
			(type) c
			(layer)1
				Element:p
					We're sure we're missing critical tips. Let us know by
				Element:a
					tweeting to @SlackAPI
					!
			Node:
			(type) h1
			(layer)1
				Element:h1
					Answers to questions we're often asked.
			Node:
			(type) c
			(layer)1
				Element:ul
				Element:li
				Element:a
					General
				Element:li
				Element:a
					Authentication
				Element:li
				Element:a
					Bot users
				Element:li
				Element:a
					Slash commands
				Element:li
				Element:a
					Incoming webhooks
				Element:li
				Element:a
					Message buttons
				Element:li
				Element:a
					Web API
				Element:li
				Element:a
					Real Time Messaging API
				Element:li
				Element:a
					Events API
				Element:li
				Element:a
					Slack apps
				Element:li
				Element:a
					Legacy custom integrations
			Node:
			(type) c
			(layer)1
				Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								General
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I set up my developer environment?
									Node:
									(type) c
									(layer)3
										Element:p
											There's no explicit sandbox or developer environment available to work against. Instead, you'll need to use a team you've created or are a member of.
									Node:
									(type) c
									(layer)3
										Element:p
											It's best to keep your integration or app's ownership contained within the team that is responsible for it.
									Node:
									(type) c
									(layer)3
										Element:p
											Start by
										Element:a
											building a Slack app
											to contain all of your work -- by default, it can only (
										Element:em
											& easily!
											) be installed on your own team. Follow the UI instructions to add features â€” most require that you provide a HTTP server Slack can reach.
									Node:
									(type) c
									(layer)3
										Element:p
											While developing for your own teams or if developing
										Element:a
											internal integrations
											, HTTPS will not be required for requests sent from Slack. This is for ease in getting started; we strongly recommend using HTTPS even for internal integrations.
									Node:
									(type) c
									(layer)3
										Element:p
											Many developers find using HTTP tunneling software effective while building apps. For one such story, consult this tutorial:
										Element:a
											Tunneling with ngrok
											.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How are incoming webhooks, slash commands, and bot users different?
									Node:
									(type) c
									(layer)3
										Element:p
											All three integration types allow you to post messages within a channel but differ in how those messages are triggered and how users interact with your app.
									Node:
									(type) c
									(layer)3
										Element:p
											You can use all of these integration types together in your Slack app.
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:a
											Incoming webhooks
											- send messages to a channel at will by using a specific URL. Best used when activity that would incite posting a message occurs in a remote service.
										Element:ul
										Element:li
											Example: If you have an issue tracking system and want to post to a channel when a bug is created or resolved, use an incoming webhook invoked from your issue tracking system.
										Element:li
										Element:a
											Slash commands
											- team members execute slash commands from within Slack, resulting in us triggering your server to return them a message. The message can either be displayed only to the executing user, or to the channel from which it was triggered.
										Element:ul
										Element:li
											Example: Your slash command allows users to create and resolve bugs from the Slack command line with either action resulting in a message being displayed to that channel.
										Element:li
										Element:a
											Bot users
											- Your service monitors channels and direct messages for certain conversational triggers, like specific text in messages posted or emoji responses. As appropriate, your bot user posts messages or performs tasks inside or outside of Slack on a team's behalf.
										Element:ul
										Element:li
											Example: Your bot monitors a channel's messages for specific issue IDs and sends the channel a message containing details about them.
										Element:li
											Example: Your bot tracks a team's emoji reactions and sends a message at the end of the day to celebrate those most used.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do custom integrations and Slack apps differ?
									Node:
									(type) c
									(layer)3
										Element:p
											On their own,
										Element:a
											custom integrations
											are for a specific team to use. An incoming webhook is a single custom integration. A bot user is a single custom integration. Same with a slash command. The tokens and credentials used for these custom integrations are intended only for the team that originated them.
									Node:
									(type) c
									(layer)3
										Element:p
											A
										Element:a
											Slack app
											is a packaged collection of one or more platform features. They can
										Element:em
											optionally
											be made available for Slack teams to install and utilize. Teams will use an
										Element:a
											OAuth 2.0
											authorization flow to approve apps, resulting in team-specific OAuth tokens for use on their behalf.
									Node:
									(type) c
									(layer)3
										Element:p
											Other differences include:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
											Incoming webhooks packaged as Slack apps cannot change their channel, icon, and username at runtime, while custom integration-based webhooks can.
										Element:li
											The permission model afforded to bot users packaged as Slack apps is slightly different. Review the bot user
										Element:a
											method list
											for more detail.
									Node:
									(type) c
									(layer)3
										Element:p
											We strongly recommend building
										Element:a
											internal integrations
											as part of a Slack app instead. Slack apps are better scoped, allowing your integration to only use the permissions they need. Additionally, you can use new features like interactive messages and the Events API.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Authentication
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I authenticate my requests to Slack?
									Node:
									(type) c
									(layer)3
												Node:
												(type) c
												(layer)4
													Element:h4
														By token
												Node:
												(type) c
												(layer)4
													Element:p
														When working with
													Element:a
														Slack apps
														or
													Element:a
														Web API
														, you'll often need to send access tokens, also known as bearer tokens, along with inbound requests using the
													Element:code
														token
														query parameter.
												Node:
												(type) c
												(layer)4
													Element:p
														Some of the tokens you'll be given while going through the integration creation process. Other tokens you obtain by sending team users through the
													Element:em
														.
													Element:a
														OAuth 2.0 authentication flow
												Node:
												(type) c
												(layer)4
													Element:p
														When you're working with Slack apps, you'll be awarded access tokens after a user approves your application.
												Node:
												(type) c
												(layer)4
													Element:p
														You can also obtain team-specific test tokens for use with the
													Element:a
														Web API
														using
													Element:a
														our token generator
														, but they should not be shared with the public or other teams.
									Node:
									(type) c
									(layer)3
												Node:
												(type) c
												(layer)4
													Element:h4
														By private URL
												Node:
												(type) c
												(layer)4
													Element:p
														Your
													Element:a
														incoming webhooks
														URLs are unique for your integration or application and do not require token-based authentication.
													Element:a
														Slash command response URLs
														also already encode your integration or application's identity.
												Node:
												(type) c
												(layer)4
													Element:p
														Webhook URLs generated by
													Element:a
														also encode the information you need to connect, though requesting
													Element:code
														rtm.start
													Element:code
														rtm.start
														itself requires a
													Element:code
														token
														as described above.
												Node:
												(type) c
												(layer)4
													Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How does Slack authenticate its requests to my servers?
									Node:
									(type) c
									(layer)3
										Element:p
											When you configure
										Element:a
											Outgoing webhooks
											,
										Element:a
											Slash commands
											and [Message buttons](/docs/message-buttons, you specify a URL for Slack to send requests when qualifying conditions are met. Slack also provides you a token related to that integration.
									Node:
									(type) c
									(layer)3
										Element:p
											Slack sends that URL a JSON payload containing a
										Element:code
											token
											field. Compare that field to values you've received from Slack. See
										Element:a
											validating slash commands
											for more information.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											When do authorization codes expire?
									Node:
									(type) c
									(layer)3
										Element:p
											Authorization codes must be exchanged for an access token within 10 minutes by calling
										Element:a
											oauth.access
											as part of the
										Element:a
											authorization flow
											. Otherwise, the authorization code will expire and you will need to ask the user to go through OAuth again.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I revoke a token?
									Node:
									(type) c
									(layer)3
										Element:p
											There is no programmatic way for you to revoke tokens issued to your integration or app. Team members and administrators can remove your app through their
										Element:a
											team administration interface
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Though it's somewhat of a nuclear option, you also have the ability to revoke all tokens from your
										Element:a
											developer dashboard
											by selecting your application and using the
										Element:em
											Revoke all tokens
											button found there.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I reset my client secret?
									Node:
									(type) c
									(layer)3
										Element:p
											To reset your client secret, go to your
										Element:a
											developer dashboard
											, select the application you are concerned about, use the
										Element:em
											Change secret
											button found there.
									Node:
									(type) c
									(layer)3
										Element:p
											Don't forget to use your new secret when exchanging authorization codes for access tokens while authorizing users and teams with
										Element:a
											OAuth 2.0
											.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How long are token strings?
									Node:
									(type) c
									(layer)3
										Element:p
											Token strings could potentially be as long as 255 characters. Historically and typically, they've been shorter.
										Element:a
											Learn more
											.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Bot users
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I use API methods with my bot user token?
									Node:
									(type) c
									(layer)3
										Element:p
											When a Slack App is approved that contains a bot user, you're awarded two tokens. The bot user token is for performing certain actions directly as the bot user, like posting a message or connecting to the real time messaging API.
									Node:
									(type) c
									(layer)3
										Element:p
											If you want to make Web API calls more generally, based on the scopes you've negotiated, you'll want to use the broader token you were awarded at approval time.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Slash commands
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Why does Slack never reach my slash command URL?
									Node:
									(type) c
									(layer)3
										Element:p
											Typically, if Slack cannot reach your slash command URL it's because it's either inaccessible, does not have a valid, verifiable SSL certificate, or because our request is timing out for some reason.
									Node:
									(type) c
									(layer)3
										Element:p
											Slack invokes slash command URLs from its servers rather than from a Slack client app like Slack for Mac. This means that the URL we're trying to reach must be accessible to Slack's servers.
									Node:
									(type) c
									(layer)3
										Element:p
											To determine whether your certificate is valid, consider using
										Element:a
											this tool
											provided by SSL Labs.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I validate a slash command's origin?
									Node:
									(type) c
									(layer)3
										Element:p
											Keep track of the validation tokens and team IDs Slack gives you when commands are created and teams approve your app. Always validate that the
										Element:code
											token
											field in an incoming slash command request has been issued to you by Slack and scope your data for that team.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Incoming webhooks
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Why can't I override the channel, icon, or user name of my incoming webhook?
									Node:
									(type) c
									(layer)3
										Element:p
											You won't be able to override any of these fields when using an
										Element:a
											incoming webhook
											attached to a
										Element:a
											Slack app
											. Instead, those values will be provided from your Slack app configuration and any configuration provided by the team.
									Node:
									(type) c
									(layer)3
										Element:p
											If you're using a
										Element:a
											custom integration
											, verify that the icon URL you're providing corresponds to a publicly accessible image resource and that the provided username or channel is valid.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Message buttons
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I use message buttons with a custom integration that's not part of a Slack app?
									Node:
									(type) c
									(layer)3
										Element:p
											At this time a
										Element:a
											Slack app
											is required to functionally
										Element:a
											attach buttons to messages
											. Message buttons require a configured action URL that is part of a Slack application record.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Can I use a self-signed certificate for my action URL?
									Node:
									(type) c
									(layer)3
										Element:p
											No, SSL certificates must be signed by a reputable certificate authority.
									Node:
									(type) c
									(layer)3
										Element:p
											You may want to consider using one of the following low-cost providers: *
										Element:a
											Let's Encrypt
											*
										Element:a
											CloudFlare
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Web API
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How is the API rate limited?
									Node:
									(type) c
									(layer)3
										Element:p
											Slack rate limits all aspects of platform use with many factors. Rate limits are currently unpublished. Review our
										Element:a
											rate limiting
											documentation for more detail.
									Node:
									(type) c
									(layer)3
										Element:p
											The guiding spirit of Slack's rate limiting is to ensure that teams are able to communicate effortlessly and without distraction.
									Node:
									(type) c
									(layer)3
										Element:p
											Because the limits are unpublished, you won't know that you're about to hit a rate limit in advance. You will receive a
										Element:code
											HTTP 429 Too Many Requests
											rate limited message in response to a request and will then need to wait for the next rate limiting window to open.
									Node:
									(type) c
									(layer)3
										Element:p
											The next rate limit is indicated by a HTTP header called
										Element:code
											Retry-After
											, presented in seconds to wait before attempting another request. If the value were
										Element:code
											10
											, then you should wait 10 seconds or more before retrying that request.
									Node:
									(type) c
									(layer)3
										Element:p
											You may find that you can't perform certain bursty actions, like attempting to message every member of a large team simultaneously. In some cases, hitting rate limits may be a symptom that there are better ways to to accomplish your goal. Some times you just need to work slower.
									Node:
									(type) c
									(layer)3
										Element:p
										Element:a
											Bot users
											associated with many teams may hit rate limits while using
										Element:a
											too quickly. Queue up your connection requests or throttle otherwise after your service restarts.
										Element:code
											rtm.start
									Node:
									(type) c
									(layer)3
										Element:p
											Finally, developers working with the
										Element:a
											Real Time Messaging API
											have special considerations worth reading
										Element:a
											in context
											.
									Node:
									(type) c
									(layer)3
										Element:p
											For more information, consult our
										Element:a
											rate limiting documentation
											.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I work with files?
									Node:
									(type) c
									(layer)3
										Element:p
											The Real Time Messaging API and other
										Element:a
											API methods
											reference
										Element:a
											file objects
											that contain a suite of details about the content type of the file and absolute URLs where those files can be retrieved or used for display.
									Node:
									(type) c
									(layer)3
										Element:p
											As of January 4th, 2016, applications must provide authentication to access the actual files that file objects reference. There's a
										Element:a
											blog post
											discussing this change of behavior.
									Node:
									(type) c
									(layer)3
										Element:p
											File objects contain
										Element:code
											url_private
											and
										Element:code
											url_private_download
											fields, as well as fields for private thumbnail URLs as applicable.
									Node:
									(type) c
									(layer)3
										Element:p
											To retrieve these URLs, you must provide a HTTP Authentication header containing a bearer token that's been awarded the
										Element:code
											files:read
											or
										Element:code
											read
										Element:a
											scopes
											.
									Node:
									(type) c
									(layer)3
										Element:p
											For example, to retrieve a
										Element:code
											thumb_360
											field containing
										Element:code
											https://files.slack.com/files-tmb/Z0CHK-THSCH5-5SZ0UT/cheese.jpg
											and your bearer token was
										Element:code
											VALID_TOKEN
											, you'd need to send a request like this:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											GET https://files.slack.com/files-tmb/Z0CHK-THSCH5-5SZ0UT/cheese.jpg Authorization: VALID_TOKEN
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I find a channel's ID if I only have its #name?
									Node:
									(type) c
									(layer)3
										Element:p
											For
										Element:em
											public channels
											, use
										Element:a
											to retrieve the list of channels. The list includes each channel's
										Element:code
											channels.list
										Element:code
											name
											and
										Element:code
											id
											fields.
									Node:
									(type) c
									(layer)3
										Element:p
											For
										Element:em
											private channels
											, use
										Element:a
											. It works the same way.
										Element:code
											groups.list
									Node:
									(type) c
									(layer)3
										Element:p
											Many developers keep the list of channels in memory for swifter lookups. Poll the method occasionally to refresh your inventory.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I find a channel's name if I only have its ID?
									Node:
									(type) c
									(layer)3
										Element:p
											You can use similar instructions to the question above, or you can use dedicated methods to look up a channel by its ID.
									Node:
									(type) c
									(layer)3
										Element:p
											For
										Element:em
											public channels
											, use
										Element:a
											to obtain a specific channel's information, including its
										Element:code
											channels.info
										Element:code
											name
											.
									Node:
									(type) c
									(layer)3
										Element:p
											For
										Element:em
											private channels
											, use
										Element:a
											. You'll find everything you want to know about a specific private channel.
										Element:code
											groups.info
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Do channel IDs stay the same when the name of the channel changes?
									Node:
									(type) c
									(layer)3
										Element:p
											Channel IDs remain the same even when the names are changed, but if a channel becomes private the ID will change.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Why are private channels referred to as groups?
									Node:
									(type) c
									(layer)3
										Element:p
											Private channels were first conceived of as group objects, and the names of the objects, events, and methods were chosen then. We decided that "private channels" made more sense for users, but already had developers, both internal and external, using the
										Element:code
											group
											namespace.
									Node:
									(type) c
									(layer)3
										Element:p
											When you see references to these groups, just rewire your brain to call them private channels instead, even though you'll be calling them
										Element:code
											group
											in your code.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I retrieve a single message?
									Node:
									(type) c
									(layer)3
										Element:p
											Use
										Element:a
											and a token with the
										Element:code
											channels.history
										Element:code
											channels:history
											scope to retrieve a specific message in a channel.
									Node:
									(type) c
									(layer)3
										Element:p
											You'll need that message's
										Element:code
											ts
											value, which uniquely identifies it within a channel. You'll also need that channel's ID value.
									Node:
									(type) c
									(layer)3
										Element:p
										Element:code
											channels.history
											takes a
										Element:code
											latest
											parameter, which you'll provide that
										Element:code
											ts
											value for. By specifying
										Element:code
											true
											for the
										Element:code
											inclusive
											parameter and setting the
										Element:code
											count
											to
										Element:code
											1
											, you'll receive exactly that message in return:
									Node:
									(type) c
									(layer)3
										Element:pre
										Element:code
											GET /api/channels.history?token=TOKEN_WITH_CHANNELS_HISTORY_SCOPE&channel=C2EB2QT8A&latest=1476909142.000007&inclusive=true&count=1
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Real Time Messaging API
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I connect to a websocket?
									Node:
									(type) c
									(layer)3
										Element:p
											The first step is making a typical HTTP request to the
										Element:a
											method. Within that response, you'll find a
										Element:code
											rtm.start
										Element:code
											url
											field beginning with the URI protocol
										Element:code
											wss://
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Then, use a Websocket client to open a long-lived connection to that time-sensitive URL. While the connection is open, you'll be streamed
										Element:a
											events
											associated with the team you're connecting on behalf of and can in turn
										Element:a
											send messages
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Typical HTTP client libraries and tools do not support connecting to websockets directly. You will need to find a client library for your preferred programming environment.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Events API
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											When should I use the Events API and when should I use the RTM API?
									Node:
									(type) c
									(layer)3
										Element:p
											Choose the
										Element:a
											Events API
											if:
									Node:
									(type) c
									(layer)3
										Element:ol
										Element:li
											You want to precisely
										Element:a
											scope
											the data you receive to just what your app needs
										Element:li
											You prefer or must use an inbound request model due to a) your hosting service not being able to maintain an outbound websocket connection b) you prefer to scale your application on an inbound request model instead of maintaining multiple long-lived websocket connections
										Element:li
											You're converting a
										Element:a
											outgoing webhook
											integration into something installable as a Slack app.
										Element:li
											You don't need data presented to you in real time as a firehose of information
										Element:li
											You find the
										Element:a
											retry behavior
											reassuring for redundancy reasons
									Node:
									(type) c
									(layer)3
										Element:p
											Or choose the
										Element:a
											RTM API
											if:
									Node:
									(type) c
									(layer)3
										Element:ol
										Element:li
											You can't or won't create a
										Element:a
											Slack app
											to contain your creations
										Element:li
											You're building an on-premise integration or have no ability to receive external HTTP requests
										Element:li
											You're working on a distributed or mobile application without a server backend
										Element:li
											You just prefer working with websockets. That's cool.
										Element:li
											You need
										Element:a
											events
											that just aren't supported by the Events API
										Element:li
											You need compatibility with today's
										Element:a
											existing tools
										Element:li
											Sending
										Element:a
											events is important for your app or bot user's sense of self and agency
										Element:code
											user_typing
										Element:li
											You want data feed redundancy by opening additional websocket connections, or perhaps will augment with the Events API anyhow
										Element:li
											You want messages to be delivered to you in real time
										Element:li
											Receiving events in absolute order is important to you.
									Node:
									(type) c
									(layer)3
										Element:p
											Or why not use the Events API and RTM API together?
									Node:
									(type) c
									(layer)3
										Element:ol
										Element:li
											Receive event data two different ways to help redundancy needs
										Element:li
											You want to work with the Events API but you need time to transition from one to the other
										Element:li
											You want to better separate concerns or follow a more service-oriented architecture
										Element:li
											You want to offer the perks presented by either API as a premium application feature.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How do I make my bot appear active and present?
									Node:
									(type) c
									(layer)3
										Element:p
											The answer depends on whether you're using the Events API with or without the RTM API.
									Node:
									(type) c
									(layer)3
										Element:p
											With the Events API, you must toggle your presence by
										Element:a
											managing your app
											's bot user config.
									Node:
									(type) c
									(layer)3
										Element:p
											With the RTM API, your bot is marked
										Element:code
											active
											while connected to a websocket.
									Node:
									(type) c
									(layer)3
										Element:p
											See
										Element:a
											bot presence
											for further
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Slack apps
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											How does my app get approved for the directory?
									Node:
									(type) c
									(layer)3
										Element:ol
										Element:li
											Build your integration points with Slack using
										Element:a
											Custom Integrations
										Element:li
											Create a
										Element:a
											Slack app
											record to package your integration points and obtain your app's platform credentials for use in
										Element:a
											authentication
											and the
										Element:a
											"Add to Slack" button
											.
										Element:li
											Review
										Element:a
											this checklist
											to make sure your app is prepared for approval process.
										Element:li
										Element:a
											Submit your application for review
											.
										Element:li
											Slack will review your application and approve it if it meets our criteria.
									Node:
									(type) c
									(layer)3
										Element:p
											Please be patient as our team regularly reviews submissions. To help the process go as smoothly as possible, we strongly recommend making sure you've followed
										Element:a
											the checklist
											before submitting.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											What happens if I make changes to an application that has been approved for the directory?
									Node:
									(type) c
									(layer)3
										Element:p
											If you need to update your approved app to request new
										Element:a
											OAuth scopes
											, include
										Element:a
											message buttons
											or add other new features, find your application's configuration page at
										Element:a
											https://api.slack.com/apps
											and indicate you'd like to make changes.
									Node:
									(type) c
									(layer)3
										Element:p
											We'll then automatically create a copy of your published app for you to use while making and testing updates in a sandboxed environment.
									Node:
									(type) c
									(layer)3
										Element:p
											Once you're ready to push the updated version of your app to users, simply re-submit it for review using the process described above.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											What kind of changes to my app will require being reviewed again?
									Node:
									(type) c
									(layer)3
										Element:p
											If you've submitted your app to the directory but need to make changes to how your app or bot is described, or changes to the integration types packed into your app, or to request additional permissions, you'll need your app to be reviewed again.
									Node:
									(type) c
									(layer)3
										Element:p
											Use the beta application corresponding to your submitted Slack app to make modifications to any of these features:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
											Requesting new OAuth permission
										Element:a
											scopes
										Element:li
											Changing your message button action URLs
										Element:li
											Changing your slash command execution URLs & other details about your
										Element:a
											slash command
										Element:li
											Changing your
										Element:a
											Events API
											subscription URLs or subscriptions
										Element:li
											Changing your
										Element:a
											bot user's
											username
										Element:li
											Changing your app's OAuth configuration
										Element:li
											Changing details about how your application is presented in the directory
										Element:ul
										Element:li
											Application description
										Element:li
											Contact information
										Element:li
											Application icon
										Element:li
											Policy & Website URLs
										Element:li
											etc.
									Node:
									(type) c
									(layer)3
										Element:p
											Your client secret and verification tokens may be regenerated as needed, without requesting further review.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Do I need to submit my Slack App to the directory if I don't want to?
									Node:
									(type) c
									(layer)3
										Element:p
											No, only submit your app to the directory if you want your app to be discoverable and installable from the directory. If you don't submit your app, we won't display it there but it will be installable by any team you give the authorization URL to.
									Node:
									(type) c
									(layer)3
										Element:a
			Node:
			(type) c
			(layer)1
						Node:
						(type) c
						(layer)2
							Element:h2
								Legacy custom integrations
						Node:
						(type) c
						(layer)2
							Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Are custom integrations deprecated?
									Node:
									(type) c
									(layer)3
										Element:p
											No, custom integrations are still documented and available to create and configure. We do strongly encourage all developers and users working with custom integrations to utilize
										Element:a
											internal integrations
											as part of a
										Element:a
											Slack app
											instead.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											What can custom integrations do that Slack apps cannot?
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:a
											Outgoing webhooks
											are not available as part of Slack apps, though you can build somewhat similar functionality using the
										Element:a
											Events API
											and the
										Element:a
											Web API
											together.
										Element:li
											Legacy
										Element:a
											incoming webhooks
											allow you to dynamically set the authorship and destination for posted messages. In Slack apps, you must create a new webhook for each destination and authorship is tied directly to your application.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											What can Slack apps do that custom integrations cannot?
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:a
											Message buttons
											- Making your messages interactive with buttons is not possible without a Slack app.
										Element:li
										Element:a
											Events API
											- The only way to dispatch events to your HTTP server is via the
										Element:a
											Events API
											, which requires a Slack app to operate.
										Element:li
										Element:a
											Scoped permissions
											- Slack apps are granted only the permissions they need to function.
										Element:li
										Element:a
											Feature bundling
											- Multiple platform features like
										Element:a
											incoming webhooks
											and
										Element:a
											slash commands
											can be packaged together into a single installable unit.
										Element:li
										Element:a
											Distribution
											- If desired, Slack apps can be installed by other teams.
									Node:
									(type) c
									(layer)3
										Element:a
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Who moved my cheese?
									Node:
									(type) c
									(layer)3
										Element:p
											It was
										Element:code
											@colonel_mustard
											in the
										Element:code
											#conservatory
											with the
										Element:code
											:fork_and_knife:
											. A custom and internal investigation will follow this Slack app fact.
									Node:
									(type) c
									(layer)3
										Element:footer
										Element:ul
										Element:li
											Using Slack
										Element:li
										Element:a
											Product
										Element:li
										Element:a
											Pricing
										Element:li
										Element:a
											Support
										Element:li
										Element:a
											Slack Guides
										Element:li
										Element:a
											Video Guides
										Element:li
										Element:a
											App Directory
										Element:li
										Element:a
											API
										Element:ul
										Element:li
											Slack
										Element:li
										Element:a
											Jobs
										Element:li
										Element:a
											Customers
										Element:li
										Element:a
											Developers
										Element:li
										Element:a
											Events
										Element:li
										Element:a
											Blog
										Element:li
										Element:a
											Podcast
										Element:li
										Element:a
											Slack Shop
										Element:ul
										Element:li
											Legal
										Element:li
										Element:a
											Privacy
										Element:li
										Element:a
											Security
										Element:li
										Element:a
											Terms of Service
										Element:li
										Element:a
											Policies
										Element:ul
										Element:li
											Handy Links
										Element:li
										Element:a
											Download desktop app
										Element:li
										Element:a
											Download mobile app
										Element:li
										Element:a
											Brand Guidelines
										Element:li
										Element:a
											Slack at Work
										Element:li
										Element:a
											Status
										Element:a
										Element:ul
										Element:li
										Element:a
											Contact Us
										Element:li
										Element:a
										Element:li
										Element:a
