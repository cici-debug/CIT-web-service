Node:
(type) c
(layer)0
	Element:body
						Node:
						(type) h2
						(layer)2
							Element:h2
							Element:a
								Query String Query
							Element:a
								edit
						Node:
						(type) c
						(layer)2
							Element:p
								A query that uses a query parser in order to parse its content. Here is an example:
						Node:
						(type) c
						(layer)2
							Element:pre
								GET /_search { "query": { "query_string" : { "default_field" : "content", "query" : "this AND that OR thus" } } }
						Node:
						(type) c
						(layer)2
							Element:p
								The
							Element:code
								query_string
								top level parameters include:
						Node:
						(type) c
						(layer)2
							Element:table
							Element:colgroup
							Element:col
							Element:col
							Element:thead
							Element:tr
							Element:th
								Parameter
							Element:th
								Description
							Element:tbody
							Element:tr
							Element:td
							Element:p
							Element:code
								query
							Element:td
							Element:p
								The actual query to be parsed. See
							Element:a
								Query string syntax
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								default_field
							Element:td
							Element:p
								The default field for query terms if no prefix field is specified. Defaults to the
							Element:code
								index.query.default_field
								index settings, which in turn defaults to
							Element:code
								_all
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								default_operator
							Element:td
							Element:p
								The default operator used if no explicit operator is specified. For example, with a default operator of
							Element:code
								OR
								, the query
							Element:code
								capital of Hungary
								is translated to
							Element:code
								capital OR of OR Hungary
								, and with default operator of
							Element:code
								AND
								, the same query is translated to
							Element:code
								capital AND of AND Hungary
								. The default value is
							Element:code
								OR
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								analyzer
							Element:td
							Element:p
								The analyzer name used to analyze the query string.
							Element:tr
							Element:td
							Element:p
							Element:code
								allow_leading_wildcard
							Element:td
							Element:p
								When set,
							Element:code
								*
								or
							Element:code
								?
								are allowed as the first character. Defaults to
							Element:code
								true
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								enable_position_increments
							Element:td
							Element:p
								Set to
							Element:code
								true
								to enable position increments in result queries. Defaults to
							Element:code
								true
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								fuzzy_max_expansions
							Element:td
							Element:p
								Controls the number of terms fuzzy queries will expand to. Defaults to
							Element:code
								50
							Element:tr
							Element:td
							Element:p
							Element:code
								fuzziness
							Element:td
							Element:p
								Set the fuzziness for fuzzy queries. Defaults to
							Element:code
								AUTO
								. See
							Element:a
								the section called “Fuzziness
							Element:a
								edit
								” for allowed settings.
							Element:tr
							Element:td
							Element:p
							Element:code
								fuzzy_prefix_length
							Element:td
							Element:p
								Set the prefix length for fuzzy queries. Default is
							Element:code
								0
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								phrase_slop
							Element:td
							Element:p
								Sets the default slop for phrases. If zero, then exact phrase matches are required. Default value is
							Element:code
								0
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								boost
							Element:td
							Element:p
								Sets the boost value of the query. Defaults to
							Element:code
								1.0
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								auto_generate_phrase_queries
							Element:td
							Element:p
								Defaults to
							Element:code
								false
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								analyze_wildcard
							Element:td
							Element:p
								By default, wildcards terms in a query string are not analyzed. By setting this value to
							Element:code
								true
								, a best effort will be made to analyze those as well.
							Element:tr
							Element:td
							Element:p
							Element:code
								max_determinized_states
							Element:td
							Element:p
								Limit on how many automaton states regexp queries are allowed to create. This protects against too-difficult (e.g. exponentially hard) regexps. Defaults to 10000.
							Element:tr
							Element:td
							Element:p
							Element:code
								minimum_should_match
							Element:td
							Element:p
								A value controlling how many "should" clauses in the resulting boolean query should match. It can be an absolute value (
							Element:code
								2
								), a percentage (
							Element:code
								30%
								) or a
							Element:a
								combination of both
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								lenient
							Element:td
							Element:p
								If set to
							Element:code
								true
								will cause format based failures (like providing text to a numeric field) to be ignored.
							Element:tr
							Element:td
							Element:p
							Element:code
								time_zone
							Element:td
							Element:p
								Time Zone to be applied to any range query related to dates. See also
							Element:a
								JODA timezone
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								quote_field_suffix
							Element:td
							Element:p
								A suffix to append to fields for quoted parts of the query string. This allows to use a field that has a different analysis chain for exact matching. Look
							Element:a
								here
								for a comprehensive example.
							Element:tr
							Element:td
							Element:p
							Element:code
								split_on_whitespace
							Element:td
							Element:p
								Whether query text should be split on whitespace prior to analysis. Instead the queryparser would parse around only real
							Element:span
								. Default to
							Element:em
								operators
							Element:code
								false
								. It is not allowed to set this option to
							Element:code
								false
								if
							Element:code
								auto_generate_phrase_queries
								is already set to
							Element:code
								true
								.
							Element:tr
							Element:td
							Element:p
							Element:code
								all_fields
							Element:td
							Element:p
								Perform the query on all fields detected in the mapping that can be queried. Will be used by default when the
							Element:code
								_all
								field is disabled and no
							Element:code
								default_field
								is specified (either in the index settings or in the request body) and no
							Element:code
								fields
								are specified.
						Node:
						(type) c
						(layer)2
							Element:p
								When a multi term query is being generated, one can control how it gets rewritten using the
							Element:a
								rewrite
								parameter.
						Node:
						(type) c
						(layer)2
												Node:
												(type) c
												(layer)4
													Element:h4
													Element:a
														Default Field
													Element:a
														edit
												Node:
												(type) c
												(layer)4
													Element:p
														When not explicitly specifying the field to search on in the query string syntax, the
													Element:code
														index.query.default_field
														will be used to derive which field to search on. It defaults to
													Element:code
														_all
														field.
												Node:
												(type) c
												(layer)4
													Element:p
														If the
													Element:code
														_all
														field is disabled, the
													Element:code
														query_string
														query will automatically attempt to determine the existing fields in the index’s mapping that are queryable, and perform the search on those fields. Note that this will not include nested documents, use a nested query to search those documents.
						Node:
						(type) c
						(layer)2
												Node:
												(type) c
												(layer)4
													Element:h4
													Element:a
														Multi Field
													Element:a
														edit
												Node:
												(type) c
												(layer)4
													Element:p
														The
													Element:code
														query_string
														query can also run against multiple fields. Fields can be provided via the
													Element:code
														"fields"
														parameter (example below).
												Node:
												(type) c
												(layer)4
													Element:p
														The idea of running the
													Element:code
														query_string
														query against multiple fields is to expand each query term to an OR clause like this:
												Node:
												(type) c
												(layer)4
													Element:pre
														field1:query_term OR field2:query_term | ...
												Node:
												(type) c
												(layer)4
													Element:p
														For example, the following query
												Node:
												(type) c
												(layer)4
													Element:pre
														GET /_search { "query": { "query_string" : { "fields" : ["content", "name"], "query" : "this AND that" } } }
												Node:
												(type) c
												(layer)4
													Element:p
														matches the same words as
												Node:
												(type) c
												(layer)4
													Element:pre
														GET /_search { "query": { "query_string": { "query": "(content:this OR name:this) AND (content:that OR name:that)" } } }
												Node:
												(type) c
												(layer)4
													Element:p
														Since several queries are generated from the individual search terms, combining them can be automatically done using either a
													Element:code
														dis_max
														query or a simple
													Element:code
														bool
														query. For example (the
													Element:code
														name
														is boosted by 5 using
													Element:code
														^5
														notation):
												Node:
												(type) c
												(layer)4
													Element:pre
														GET /_search { "query": { "query_string" : { "fields" : ["content", "name^5"], "query" : "this AND that OR thus", "use_dis_max" : true } } }
												Node:
												(type) c
												(layer)4
													Element:p
														Simple wildcard can also be used to search "within" specific inner elements of the document. For example, if we have a
													Element:code
														city
														object with several fields (or inner object with fields) in it, we can automatically search on all "city" fields:
												Node:
												(type) c
												(layer)4
													Element:pre
														GET /_search { "query": { "query_string" : { "fields" : ["city.*"], "query" : "this AND that OR thus", "use_dis_max" : true } } }
												Node:
												(type) c
												(layer)4
													Element:p
														Another option is to provide the wildcard fields search in the query string itself (properly escaping the
													Element:code
														*
														sign), for example:
													Element:code
														city.\*:something
														:
												Node:
												(type) c
												(layer)4
													Element:pre
														GET /_search { "query": { "query_string" : { "query" : "city.\\*:(this AND that OR thus)", "use_dis_max" : true } } }
												Node:
												(type) c
												(layer)4
													Element:img
												Node:
												(type) c
												(layer)4
													Element:p
														Since
													Element:code
														\
														(backslash) is a special character in json strings, it needs to be escaped, hence the two backslashes in the above
													Element:code
														query_string
														.
												Node:
												(type) c
												(layer)4
													Element:p
														When running the
													Element:code
														query_string
														query against multiple fields, the following additional parameters are allowed:
												Node:
												(type) c
												(layer)4
													Element:table
													Element:colgroup
													Element:col
													Element:col
													Element:thead
													Element:tr
													Element:th
														Parameter
													Element:th
														Description
													Element:tbody
													Element:tr
													Element:td
													Element:p
													Element:code
														use_dis_max
													Element:td
													Element:p
														Should the queries be combined using
													Element:code
														dis_max
														(set it to
													Element:code
														true
														), or a
													Element:code
														bool
														query (set it to
													Element:code
														false
														). Defaults to
													Element:code
														true
														.
													Element:tr
													Element:td
													Element:p
													Element:code
														tie_breaker
													Element:td
													Element:p
														When using
													Element:code
														dis_max
														, the disjunction max tie breaker. Defaults to
													Element:code
														0
														.
												Node:
												(type) c
												(layer)4
													Element:p
														The fields parameter can also include pattern based field names, allowing to automatically expand to the relevant fields (dynamically introduced fields included). For example:
												Node:
												(type) c
												(layer)4
													Element:pre
														GET /_search { "query": { "query_string" : { "fields" : ["content", "name.*^5"], "query" : "this AND that OR thus", "use_dis_max" : true } } }
												Node:
												(type) c
												(layer)4
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:a
											Query string syntax
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											The query string “mini-language” is used by the
										Element:a
											Query String Query
											and by the
										Element:code
											q
											query string parameter in the
										Element:a
											.
										Element:code
											search
											API
									Node:
									(type) c
									(layer)3
										Element:p
											The query string is parsed into a series of
										Element:span
											and
										Element:em
											terms
										Element:span
											. A term can be a single word —
										Element:em
											operators
										Element:code
											quick
											or
										Element:code
											brown
											— or a phrase, surrounded by double quotes —
										Element:code
											"quick brown"
											— which searches for all the words in the phrase, in the same order.
									Node:
									(type) c
									(layer)3
										Element:p
											Operators allow you to customize the search — the available options are explained below.
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Field names
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											As mentioned in
										Element:a
											Query String Query
											, the
										Element:code
											default_field
											is searched for the search terms, but it is possible to specify other fields in the query syntax:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:p
											where the
										Element:code
											status
											field contains
										Element:code
											active
										Element:pre
											status:active
										Element:li
										Element:p
											where the
										Element:code
											title
											field contains
										Element:code
											quick
											or
										Element:code
											brown
											. If you omit the OR operator the default operator will be used
										Element:pre
											title:(quick OR brown) title:(quick brown)
										Element:li
										Element:p
											where the
										Element:code
											author
											field contains the exact phrase
										Element:code
											"john smith"
										Element:pre
											author:"John Smith"
										Element:li
										Element:p
											where any of the fields
										Element:code
											book.title
											,
										Element:code
											book.content
											or
										Element:code
											book.date
											contains
										Element:code
											quick
											or
										Element:code
											brown
											(note how we need to escape the
										Element:code
											*
											with a backslash):
										Element:pre
											book.\*:(quick brown)
										Element:li
										Element:p
											where the field
										Element:code
											title
											has any non-null value:
										Element:pre
											_exists_:title
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Wildcards
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											Wildcard searches can be run on individual terms, using
										Element:code
											?
											to replace a single character, and
										Element:code
											*
											to replace zero or more characters:
									Node:
									(type) c
									(layer)3
										Element:pre
											qu?ck bro*
									Node:
									(type) c
									(layer)3
										Element:p
											Be aware that wildcard queries can use an enormous amount of memory and perform very badly — just think how many terms need to be queried to match the query string
										Element:code
											"a* b* c*"
											.
									Node:
									(type) c
									(layer)3
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
											Allowing a wildcard at the beginning of a word (eg
										Element:code
											"*ing"
											) is particularly heavy, because all terms in the index need to be examined, just in case they match. Leading wildcards can be disabled by setting
										Element:code
											allow_leading_wildcard
											to
										Element:code
											false
											.
									Node:
									(type) c
									(layer)3
										Element:p
											Only parts of the analysis chain that operate at the character level are applied. So for instance, if the analyzer performs both lowercasing and stemming, only the lowercasing will be applied: it would be wrong to perform stemming on a word that is missing some of its letters.
									Node:
									(type) c
									(layer)3
										Element:p
											By setting
										Element:code
											analyze_wildcard
											to true, queries that end with a
										Element:code
											*
											will be analyzed and a boolean query will be built out of the different tokens, by ensuring exact matches on the first N-1 tokens, and prefix match on the last token.
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Regular expressions
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											Regular expression patterns can be embedded in the query string by wrapping them in forward-slashes (
										Element:code
											"/"
											):
									Node:
									(type) c
									(layer)3
										Element:pre
											name:/joh?n(ath[oa]n)/
									Node:
									(type) c
									(layer)3
										Element:p
											The supported regular expression syntax is explained in
										Element:a
											Regular expression syntax
											.
									Node:
									(type) c
									(layer)3
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											allow_leading_wildcard
											parameter does not have any control over regular expressions. A query string such as the following would force Elasticsearch to visit every term in the index:
									Node:
									(type) c
									(layer)3
										Element:pre
											/.*n/
									Node:
									(type) c
									(layer)3
										Element:p
											Use with caution!
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Fuzziness
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											We can search for terms that are similar to, but not exactly like our search terms, using the “fuzzy” operator:
									Node:
									(type) c
									(layer)3
										Element:pre
											quikc~ brwn~ foks~
									Node:
									(type) c
									(layer)3
										Element:p
											This uses the
										Element:a
											Damerau-Levenshtein distance
											to find all terms with a maximum of two changes, where a change is the insertion, deletion or substitution of a single character, or transposition of two adjacent characters.
									Node:
									(type) c
									(layer)3
										Element:p
											The default
										Element:span
											is
										Element:em
											edit distance
										Element:code
											2
											, but an edit distance of
										Element:code
											1
											should be sufficient to catch 80% of all human misspellings. It can be specified as:
									Node:
									(type) c
									(layer)3
										Element:pre
											quikc~1
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Proximity searches
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											While a phrase query (eg
										Element:code
											"john smith"
											) expects all of the terms in exactly the same order, a proximity query allows the specified words to be further apart or in a different order. In the same way that fuzzy queries can specify a maximum edit distance for characters in a word, a proximity search allows us to specify a maximum edit distance of words in a phrase:
									Node:
									(type) c
									(layer)3
										Element:pre
											"fox quick"~5
									Node:
									(type) c
									(layer)3
										Element:p
											The closer the text in a field is to the original order specified in the query string, the more relevant that document is considered to be. When compared to the above example query, the phrase
										Element:code
											"quick fox"
											would be considered more relevant than
										Element:code
											"quick brown fox"
											.
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Ranges
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											Ranges can be specified for date, numeric or string fields. Inclusive ranges are specified with square brackets
										Element:code
											[min TO max]
											and exclusive ranges with curly brackets
										Element:code
											{min TO max}
											.
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:p
											All days in 2012:
										Element:pre
											date:[2012-01-01 TO 2012-12-31]
										Element:li
										Element:p
											Numbers 1..5
										Element:pre
											count:[1 TO 5]
										Element:li
										Element:p
											Tags between
										Element:code
											alpha
											and
										Element:code
											omega
											, excluding
										Element:code
											alpha
											and
										Element:code
											omega
											:
										Element:pre
											tag:{alpha TO omega}
										Element:li
										Element:p
											Numbers from 10 upwards
										Element:pre
											count:[10 TO *]
										Element:li
										Element:p
											Dates before 2012
										Element:pre
											date:{* TO 2012-01-01}
									Node:
									(type) c
									(layer)3
										Element:p
											Curly and square brackets can be combined:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:p
											Numbers from 1 up to but not including 5
										Element:pre
											count:[1 TO 5}
									Node:
									(type) c
									(layer)3
										Element:p
											Ranges with one side unbounded can use the following syntax:
									Node:
									(type) c
									(layer)3
										Element:pre
											age:>10 age:>=10 age:<10 age:<=10
									Node:
									(type) c
									(layer)3
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
											To combine an upper and lower bound with the simplified syntax, you would need to join two clauses with an
										Element:code
											AND
											operator:
									Node:
									(type) c
									(layer)3
										Element:pre
											age:(>=10 AND <20) age:(+>=10 +<20)
									Node:
									(type) c
									(layer)3
										Element:p
											The parsing of ranges in query strings can be complex and error prone. It is much more reliable to use an explicit
										Element:a
											.
										Element:code
											range
											query
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Boosting
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											Use the
										Element:span
											operator
										Element:em
											boost
										Element:code
											^
											to make one term more relevant than another. For instance, if we want to find all documents about foxes, but we are especially interested in quick foxes:
									Node:
									(type) c
									(layer)3
										Element:pre
											quick^2 fox
									Node:
									(type) c
									(layer)3
										Element:p
											The default
										Element:code
											boost
											value is 1, but can be any positive floating point number. Boosts between 0 and 1 reduce relevance.
									Node:
									(type) c
									(layer)3
										Element:p
											Boosts can also be applied to phrases or to groups:
									Node:
									(type) c
									(layer)3
										Element:pre
											"john smith"^2 (foo bar)^4
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Boolean operators
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											By default, all terms are optional, as long as one term matches. A search for
										Element:code
											foo bar baz
											will find any document that contains one or more of
										Element:code
											foo
											or
										Element:code
											bar
											or
										Element:code
											baz
											. We have already discussed the
										Element:code
											default_operator
											above which allows you to force all terms to be required, but there are also
										Element:span
											which can be used in the query string itself to provide more control.
										Element:em
											boolean operators
									Node:
									(type) c
									(layer)3
										Element:p
											The preferred operators are
										Element:code
											+
											(this term
										Element:span
											be present) and
										Element:strong
											must
										Element:code
											-
											(this term
										Element:span
											be present). All other terms are optional. For example, this query:
										Element:strong
											must not
									Node:
									(type) c
									(layer)3
										Element:pre
											quick brown +fox -news
									Node:
									(type) c
									(layer)3
										Element:p
											states that:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:code
											fox
											must be present
										Element:li
										Element:code
											news
											must not be present
										Element:li
										Element:code
											quick
											and
										Element:code
											brown
											are optional — their presence increases the relevance
									Node:
									(type) c
									(layer)3
										Element:p
											The familiar operators
										Element:code
											AND
											,
										Element:code
											OR
											and
										Element:code
											NOT
											(also written
										Element:code
											&&
											,
										Element:code
											||
											and
										Element:code
											!
											) are also supported. However, the effects of these operators can be more complicated than is obvious at first glance.
										Element:code
											NOT
											takes precedence over
										Element:code
											AND
											, which takes precedence over
										Element:code
											OR
											. While the
										Element:code
											+
											and
										Element:code
											-
											only affect the term to the right of the operator,
										Element:code
											AND
											and
										Element:code
											OR
											can affect the terms to the left and right.
									Node:
									(type) c
									(layer)3
										Element:p
											Rewriting the above query using
										Element:code
											AND
											,
										Element:code
											OR
											and
										Element:code
											NOT
											demonstrates the complexity:
									Node:
									(type) c
									(layer)3
										Element:dl
										Element:dt
										Element:span
										Element:code
											quick OR brown AND fox AND NOT news
										Element:dd
											This is incorrect, because
										Element:code
											brown
											is now a required term.
										Element:dt
										Element:span
										Element:code
											(quick OR brown) AND fox AND NOT news
										Element:dd
											This is incorrect because at least one of
										Element:code
											quick
											or
										Element:code
											brown
											is now required and the search for those terms would be scored differently from the original query.
										Element:dt
										Element:span
										Element:code
											((quick AND fox) OR (brown AND fox) OR fox) AND NOT news
										Element:dd
											This form now replicates the logic from the original query correctly, but the relevance scoring bears little resemblance to the original.
									Node:
									(type) c
									(layer)3
										Element:p
											In contrast, the same query rewritten using the
										Element:a
											would look like this:
										Element:code
											match
											query
									Node:
									(type) c
									(layer)3
										Element:pre
											{ "bool": { "must": { "match": "fox" }, "should": { "match": "quick brown" }, "must_not": { "match": "news" } } }
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Grouping
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											Multiple terms or clauses can be grouped together with parentheses, to form sub-queries:
									Node:
									(type) c
									(layer)3
										Element:pre
											(quick OR brown) AND fox
									Node:
									(type) c
									(layer)3
										Element:p
											Groups can be used to target a particular field, or to boost the result of a sub-query:
									Node:
									(type) c
									(layer)3
										Element:pre
											status:(active OR pending) title:(full text search)^2
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Reserved characters
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											If you need to use any of the characters which function as operators in your query itself (and not as operators), then you should escape them with a leading backslash. For instance, to search for
										Element:code
											(1+1)=2
											, you would need to write your query as
										Element:code
											\(1\+1\)\=2
											.
									Node:
									(type) c
									(layer)3
										Element:p
											The reserved characters are:
										Element:code
											+ - = && || > < ! ( ) { } [ ] ^ " ~ * ? : \ /
									Node:
									(type) c
									(layer)3
										Element:p
											Failing to escape these special characters correctly could lead to a syntax error which prevents your query from running.
									Node:
									(type) c
									(layer)3
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
										Element:code
											<
											and
										Element:code
											>
											can’t be escaped at all. The only way to prevent them from attempting to create a range query is to remove them from the query string entirely.
									Node:
									(type) c
									(layer)3
										Element:p
										Element:strong
											Watch this space
									Node:
									(type) c
									(layer)3
										Element:p
											A space may also be a reserved character. For instance, if you have a synonym list which converts
										Element:code
											"wi fi"
											to
										Element:code
											"wifi"
											, a
										Element:code
											query_string
											search for
										Element:code
											"wi fi"
											would fail. The query string parser would interpret your query as a search for
										Element:code
											"wi OR fi"
											, while the token stored in your index is actually
										Element:code
											"wifi"
											. The option
										Element:code
											split_on_whitespace=false
											will protect it from being touched by the query string parser and will let the analysis run on the entire input (
										Element:code
											"wi fi"
											).
									Node:
									(type) c
									(layer)3
										Element:h4
										Element:a
											Empty Query
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											If the query string is empty or only contains whitespaces the query will yield an empty result set.
									Node:
									(type) c
									(layer)3
										Element:span
										Element:a
											« Common Terms Query
									Node:
									(type) c
									(layer)3
										Element:span
										Element:a
											Simple Query String Query »
												Node:
												(type) c
												(layer)4
									Node:
									(type) c
									(layer)3
										Element:h3
											Top Videos
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:a
											Elasticsearch Demo
										Element:li
										Element:a
											Kibana 101
										Element:li
										Element:a
											Logstash Primer
									Node:
									(type) c
									(layer)3
															Node:
															(type) c
															(layer)5
																Element:h5
																	Be in the know with the latest and greatest from Elastic.
															Node:
															(type) c
															(layer)5
																Element:p
																	Thanks for subscribing! We'll keep you updated with new releases.
												Node:
												(type) c
												(layer)4
									Node:
									(type) c
									(layer)3
										Element:footer
										Element:h3
										Element:a
											Products >
										Element:ul
										Element:li
										Element:a
											Elasticsearch
										Element:li
										Element:a
											Kibana
										Element:li
										Element:a
											Beats
										Element:li
										Element:a
											Logstash
										Element:li
										Element:a
											X-Pack
										Element:li
										Element:a
											Elastic Cloud
										Element:li
										Element:a
											Security (formerly Shield)
										Element:li
										Element:a
											Alerting (via Watcher)
										Element:li
										Element:a
											Monitoring (formerly Marvel)
										Element:li
										Element:a
											Graph
										Element:li
										Element:a
											Reporting
										Element:li
										Element:a
											Machine Learning
										Element:li
										Element:a
											ES-Hadoop
										Element:h3
											Resources
										Element:ul
										Element:li
										Element:a
											Blog
										Element:li
										Element:a
											Cloud Status
										Element:li
										Element:a
											Community
										Element:li
										Element:a
											Customers & Use Cases
										Element:li
										Element:a
											Documentation
										Element:li
										Element:a
											Elastic{ON} Events
										Element:li
										Element:a
											Forums
										Element:li
										Element:a
											Meetups
										Element:li
										Element:a
											Subscriptions
										Element:li
										Element:a
											Support Portal
										Element:li
										Element:a
											Videos & Webinars
										Element:li
										Element:a
											Training
										Element:h3
										Element:a
											About >
										Element:ul
										Element:li
										Element:a
											Careers/Jobs
										Element:li
										Element:a
											Contact
										Element:li
										Element:a
											Leadership
										Element:li
										Element:a
											Partners
										Element:li
										Element:a
											Press
										Element:h3
											Language
										Element:ul
										Element:li
										Element:a
											English
										Element:li
										Element:a
											Français
										Element:li
										Element:a
											Deutsch
										Element:li
										Element:a
											日本語
										Element:li
										Element:a
											한국어
										Element:p
											FOLLOW US
										Element:ul
										Element:li
										Element:a
										Element:li
										Element:a
										Element:li
										Element:a
										Element:li
										Element:a
										Element:li
										Element:a
										Element:ul
										Element:li
										Element:a
											Trademarks
										Element:li
										Element:a
											Terms of Use
										Element:li
										Element:a
											Privacy
										Element:li
										Element:a
											Cookie Policy
										Element:li
										Element:a
											Brand
										Element:a
										Element:img
										Element:p
											© 2017. All Rights Reserved - Elasticsearch
										Element:p
											Elasticsearch is a trademark of Elasticsearch BV, registered in the U.S. and in other countries
										Element:p
											Apache, Apache Lucene, Apache Hadoop, Hadoop, HDFS and the yellow elephant logo are trademarks of the
										Element:a
											Apache Software Foundation
											in the United States and/or other countries.
