Node:
(type) c
(layer)0
	Element:body
						Node:
						(type) h2
						(layer)2
							Element:h2
							Element:a
								Cardinality Aggregation
							Element:a
								edit
						Node:
						(type) c
						(layer)2
							Element:p
								A
							Element:code
								single-value
								metrics aggregation that calculates an approximate count of distinct values. Values can be extracted either from specific fields in the document or generated by a script.
						Node:
						(type) c
						(layer)2
							Element:p
								Assume you are indexing books and would like to count the unique authors that match a query:
						Node:
						(type) c
						(layer)2
							Element:pre
								{ "aggs" : { "author_count" : { "cardinality" : { "field" : "author" } } } }
						Node:
						(type) c
						(layer)2
							Element:p
								Response:
						Node:
						(type) c
						(layer)2
							Element:pre
								{ ... "aggregations": { "author_count": { "value": 19 } } }
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:a
											Precision control
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											This aggregation also supports the
										Element:code
											precision_threshold
											option:
									Node:
									(type) c
									(layer)3
										Element:img
											The precision_threshold option is specific to the current internal implementation of the cardinality agg, which may change in the future
									Node:
									(type) c
									(layer)3
										Element:pre
											{ "aggs" : { "author_count" : { "cardinality" : { "field" : "author_hash", "precision_threshold": 100
										Element:a
										Element:span
											} } } }
										Element:img
									Node:
									(type) c
									(layer)3
										Element:table
										Element:tr
										Element:td
										Element:p
										Element:a
										Element:span
										Element:img
										Element:td
										Element:p
											The
										Element:code
											precision_threshold
											options allows to trade memory for accuracy, and defines a unique count below which counts are expected to be close to accurate. Above this value, counts might become a bit more fuzzy. The maximum supported value is 40000, thresholds above this number will have the same effect as a threshold of 40000. The default values is
										Element:code
											3000
											.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:a
											Counts are approximate
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											Computing exact counts requires loading values into a hash set and returning its size. This doesn’t scale when working on high-cardinality sets and/or large values as the required memory usage and the need to communicate those per-shard sets between nodes would utilize too many resources of the cluster.
									Node:
									(type) c
									(layer)3
										Element:p
											This
										Element:code
											cardinality
											aggregation is based on the
										Element:a
											HyperLogLog++
											algorithm, which counts based on the hashes of the values with some interesting properties:
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
											configurable precision, which decides on how to trade memory for accuracy,
										Element:li
											excellent accuracy on low-cardinality sets,
										Element:li
											fixed memory usage: no matter if there are tens or billions of unique values, memory usage only depends on the configured precision.
									Node:
									(type) c
									(layer)3
										Element:p
											For a precision threshold of
										Element:code
											c
											, the implementation that we are using requires about
										Element:code
											c * 8
											bytes.
									Node:
									(type) c
									(layer)3
										Element:p
											The following chart shows how the error varies before and after the threshold:
									Node:
									(type) c
									(layer)3
										Element:p
										Element:span
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
											For all 3 thresholds, counts have been accurate up to the configured threshold (although not guaranteed, this is likely to be the case). Please also note that even with a threshold as low as 100, the error remains very low, even when counting millions of items.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:a
											Pre-computed hashes
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											On string fields that have a high cardinality, it might be faster to store the hash of your field values in your index and then run the cardinality aggregation on this field. This can either be done by providing hash values from client-side or by letting elasticsearch compute hash values for you by using the
										Element:a
											plugin.
										Element:code
											mapper-murmur3
									Node:
									(type) c
									(layer)3
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
											Pre-computing hashes is usually only useful on very large and/or high-cardinality fields as it saves CPU and memory. However, on numeric fields, hashing is very fast and storing the original values requires as much or less memory than storing the hashes. This is also true on low-cardinality string fields, especially given that those have an optimization in order to make sure that hashes are computed at most once per unique value per segment.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:a
											Script
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											cardinality
											metric supports scripting, with a noticeable performance hit however since hashes need to be computed on the fly.
									Node:
									(type) c
									(layer)3
										Element:pre
											{ "aggs" : { "author_count" : { "cardinality" : { "script": { "lang": "painless", "inline": "doc['author.first_name'].value + ' ' + doc['author.last_name'].value" } } } } }
									Node:
									(type) c
									(layer)3
										Element:p
											This will interpret the
										Element:code
											script
											parameter as an
										Element:code
											inline
											script with the
										Element:code
											painless
											script language and no script parameters. To use a file script use the following syntax:
									Node:
									(type) c
									(layer)3
										Element:pre
											{ "aggs" : { "author_count" : { "cardinality" : { "script" : { "file": "my_script", "params": { "first_name_field": "author.first_name", "last_name_field": "author.last_name" } } } } } }
									Node:
									(type) c
									(layer)3
										Element:img
									Node:
									(type) c
									(layer)3
										Element:p
											for indexed scripts replace the
										Element:code
											file
											parameter with an
										Element:code
											id
											parameter.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
										Element:a
											Missing value
										Element:a
											edit
									Node:
									(type) c
									(layer)3
										Element:p
											The
										Element:code
											missing
											parameter defines how documents that are missing a value should be treated. By default they will be ignored but it is also possible to treat them as if they had a value.
									Node:
									(type) c
									(layer)3
										Element:pre
											{ "aggs" : { "tag_cardinality" : { "cardinality" : { "field" : "tag", "missing": "N/A"
										Element:a
										Element:span
											} } } }
										Element:img
									Node:
									(type) c
									(layer)3
										Element:table
										Element:tr
										Element:td
										Element:p
										Element:a
										Element:span
										Element:img
										Element:td
										Element:p
											Documents without a value in the
										Element:code
											tag
											field will fall into the same bucket as documents that have the value
										Element:code
											N/A
											.
									Node:
									(type) c
									(layer)3
										Element:span
										Element:a
											« Avg Aggregation
									Node:
									(type) c
									(layer)3
										Element:span
										Element:a
											Extended Stats Aggregation »
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:h3
											Top Videos
									Node:
									(type) c
									(layer)3
										Element:ul
										Element:li
										Element:a
											Elasticsearch Demo
										Element:li
										Element:a
											Kibana 101
										Element:li
										Element:a
											Logstash Primer
									Node:
									(type) c
									(layer)3
															Node:
															(type) c
															(layer)5
																Element:h5
																	Be in the know with the latest and greatest from Elastic.
															Node:
															(type) c
															(layer)5
																Element:p
																	Thanks for subscribing! We'll keep you updated with new releases.
						Node:
						(type) c
						(layer)2
									Node:
									(type) c
									(layer)3
										Element:footer
										Element:h3
										Element:a
											Products >
										Element:ul
										Element:li
										Element:a
											Elasticsearch
										Element:li
										Element:a
											Kibana
										Element:li
										Element:a
											Beats
										Element:li
										Element:a
											Logstash
										Element:li
										Element:a
											X-Pack
										Element:li
										Element:a
											Elastic Cloud
										Element:li
										Element:a
											Security (formerly Shield)
										Element:li
										Element:a
											Alerting (via Watcher)
										Element:li
										Element:a
											Monitoring (formerly Marvel)
										Element:li
										Element:a
											Graph
										Element:li
										Element:a
											Reporting
										Element:li
										Element:a
											Machine Learning
										Element:li
										Element:a
											ES-Hadoop
										Element:h3
											Resources
										Element:ul
										Element:li
										Element:a
											Blog
										Element:li
										Element:a
											Cloud Status
										Element:li
										Element:a
											Community
										Element:li
										Element:a
											Customers & Use Cases
										Element:li
										Element:a
											Documentation
										Element:li
										Element:a
											Elastic{ON} Events
										Element:li
										Element:a
											Forums
										Element:li
										Element:a
											Meetups
										Element:li
										Element:a
											Subscriptions
										Element:li
										Element:a
											Support Portal
										Element:li
										Element:a
											Videos & Webinars
										Element:li
										Element:a
											Training
										Element:h3
										Element:a
											About >
										Element:ul
										Element:li
										Element:a
											Careers/Jobs
										Element:li
										Element:a
											Contact
										Element:li
										Element:a
											Leadership
										Element:li
										Element:a
											Partners
										Element:li
										Element:a
											Press
										Element:h3
											Language
										Element:ul
										Element:li
										Element:a
											English
										Element:li
										Element:a
											Français
										Element:li
										Element:a
											Deutsch
										Element:li
										Element:a
											日本語
										Element:li
										Element:a
											한국어
										Element:p
											FOLLOW US
										Element:ul
										Element:li
										Element:a
										Element:li
										Element:a
										Element:li
										Element:a
										Element:li
										Element:a
										Element:li
										Element:a
										Element:ul
										Element:li
										Element:a
											Trademarks
										Element:li
										Element:a
											Terms of Use
										Element:li
										Element:a
											Privacy
										Element:li
										Element:a
											Cookie Policy
										Element:li
										Element:a
											Brand
										Element:a
										Element:img
										Element:p
											© 2017. All Rights Reserved - Elasticsearch
										Element:p
											Elasticsearch is a trademark of Elasticsearch BV, registered in the U.S. and in other countries
										Element:p
											Apache, Apache Lucene, Apache Hadoop, Hadoop, HDFS and the yellow elephant logo are trademarks of the
										Element:a
											Apache Software Foundation
											in the United States and/or other countries.
